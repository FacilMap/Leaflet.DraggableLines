{"version":3,"sources":["webpack://L.DraggableLines/webpack/universalModuleDefinition","webpack://L.DraggableLines/./src/handler.ts","webpack://L.DraggableLines/./src/index.ts","webpack://L.DraggableLines/./src/injections.ts","webpack://L.DraggableLines/./src/markers/dragMarker.ts","webpack://L.DraggableLines/./src/markers/icons.ts","webpack://L.DraggableLines/./src/markers/marker.ts","webpack://L.DraggableLines/./src/markers/plusMarker.ts","webpack://L.DraggableLines/./src/markers/tempMarker.ts","webpack://L.DraggableLines/./src/utils.ts","webpack://L.DraggableLines/./src/markers/marker.svg","webpack://L.DraggableLines/./src/markers/plus.svg","webpack://L.DraggableLines/external {\"commonjs\":\"leaflet\",\"commonjs2\":\"leaflet\",\"amd\":\"leaflet\",\"root\":\"L\"}","webpack://L.DraggableLines/external {\"commonjs\":\"leaflet-geometryutil\",\"commonjs2\":\"leaflet-geometryutil\",\"amd\":\"leaflet-geometryutil\",\"root\":[\"L\",\"GeometryUtil\"]}","webpack://L.DraggableLines/webpack/bootstrap","webpack://L.DraggableLines/webpack/startup","webpack://L.DraggableLines/webpack/runtime/define property getters","webpack://L.DraggableLines/webpack/runtime/hasOwnProperty shorthand","webpack://L.DraggableLines/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__453__","__WEBPACK_EXTERNAL_MODULE__7__","map","options","handleLayerAdd","e","layer","Polyline","enableForLayer","handleLayerRemove","disableForLayer","handleLayerMouseOver","Draggable","_dragging","drawTempMarker","target","latlng","handleLayerSetLatLngs","removeTempMarker","_draggableLines","drawDragMarkers","drawPlusMarkers","interactive","dragMarkerOptions","i","length","icon","Polygon","defaultIcon","startIcon","endIcon","tempMarkerOptions","plusMarkerOptions","plusIcon","plusTempMarkerOptions","isStart","allowExtendingLine","removeOnClick","addHooks","this","_map","on","eachLayer","removeHooks","removeDragMarkers","latlngs","getDraggableLinesRoutePoints","getLatLngs","routePoints","LineUtil","isFlat","j","idx","marker","addTo","dragMarkers","push","fire","removeFrom","removePlusMarkers","trackPoints","getPlusIconPoint","weight","plusMarkers","_tempMarker","closest","zoomEndHandler","redrawForLayer","_layer","getLatLng","off","redraw","enable","Handler","Object","assign","DraggableLinesHandler","prototype","Evented","DraggableLinesMarker","DraggableLinesDragMarker","DraggableLinesTempMarker","DraggableLinesPlusMarker","DraggableLines","utils","icons","Marker","DragMarker","TempMarker","PlusMarker","hasDraggableLinesRoutePoints","draggableLinesRoutePoints","p","latLng","setDraggableLinesRoutePoints","setLatLngsBkp","setLatLngs","result","apply","args","draggable","_idx","_removeOnClick","onAdd","points","Array","isArray","handleClick","getIdx","removePoint","_draggable","imagePath","Icon","Default","_detectIconPath","createIcon","colors","url","default","keys","key","replace","RegExp","encodeURIComponent","String","iconUrl","iconRetinaUrl","shadowUrl","color1","color2","color3","color4","iconSize","iconAnchor","isInsert","_isInsert","handleDragStart","handleDrag","handleDragEnd","onRemove","_dragFrom","_dragIdx","setPoint","from","to","isNew","event","Promise","resolve","then","pane","zIndexOffset","_tempMarkerOptions","handleMouseOver","remove","DraggableLinesPlusTempMarker","plusMarker","_plusMarker","shouldRemove","layerPoint","latLngToLayerPoint","position","DomUtil","getPosition","_icon","Math","abs","y","offsetHeight","x","offsetWidth","getRenderPoint","baseIcon","Util","create","_setIconStyles","img","name","call","padding","style","marginLeft","parseInt","marginTop","handleMapMouseMove","DomEvent","getContainer","handleMapMouseOver","show","display","_shadow","hide","isHidden","getRouteInsertPosition","getInsertPosition","_containsPoint","GeometryUtil","distance","mouseEventToLatLng","originalEvent","setLatLng","isVisible","getElement","insertAtPosition","arr","item","idxArr","slice","updateAtPosition","removeFromPosition","point","isPolygon","polygon","polyline","pos","locateOnLine","extract","max","min","insert","hasRoutePoints","atStart","tr","reverse","point0","latLngToContainerPoint","point1","fraction","distanceTo","containerPointToLatLng","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","o","defineProperty","enumerable","get","obj","prop","hasOwnProperty","r","Symbol","toStringTag","value"],"mappings":"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","file":"L.DraggableLines.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"leaflet\"), require(\"leaflet-geometryutil\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"leaflet\", \"leaflet-geometryutil\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"L.DraggableLines\"] = factory(require(\"leaflet\"), require(\"leaflet-geometryutil\"));\n\telse\n\t\troot[\"L.DraggableLines\"] = factory(root[\"L\"], root[\"L\"][\"GeometryUtil\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__453__, __WEBPACK_EXTERNAL_MODULE__7__) {\nreturn ","import L, { Draggable, Evented, Handler, Icon, LatLng, Layer, LeafletEvent, LeafletMouseEvent, LineUtil, Map, Marker, MarkerOptions, Polygon, Polyline } from 'leaflet';\nimport GeometryUtil from 'leaflet-geometryutil';\nimport { defaultIcon, endIcon, plusIcon, startIcon } from './markers/icons';\nimport DraggableLinesDragMarker from './markers/dragMarker';\nimport DraggableLinesPlusMarker from './markers/plusMarker';\nimport DraggableLinesTempMarker from './markers/tempMarker';\nimport { getPlusIconPoint } from './utils';\n\nexport interface DraggableLinesHandlerOptions {\n    enableForLayer?: boolean | ((layer: Polyline) => boolean);\n    dragMarkerOptions?: (layer: Polyline, i: number, length: number) => MarkerOptions;\n    tempMarkerOptions?: (layer: Polyline) => MarkerOptions;\n    plusMarkerOptions?: (layer: Polyline, isStart: boolean) => MarkerOptions;\n    plusTempMarkerOptions?: (layer: Polyline, isStart: boolean) => MarkerOptions;\n    allowExtendingLine?: boolean;\n    removeOnClick?: boolean;\n}\n\nexport default class DraggableLinesHandler extends Handler {\n\n    options: DraggableLinesHandlerOptions;\n    \n    _tempMarker?: DraggableLinesTempMarker;\n\n    constructor(map: Map, options?: DraggableLinesHandlerOptions) {\n        super(map);\n\n        this.options = {\n            enableForLayer: (layer) => layer.options.interactive!,\n            dragMarkerOptions: (layer, i, length) => ({\n                icon: layer instanceof Polygon ? defaultIcon : (i == 0 ? startIcon : i == length - 1 ? endIcon : defaultIcon)\n            }),\n            tempMarkerOptions: () => ({\n                icon: defaultIcon\n            }),\n            plusMarkerOptions: () => ({\n                icon: plusIcon\n            }),\n            plusTempMarkerOptions: (layer, isStart) => ({\n                icon: isStart ? startIcon : endIcon\n            }),\n            allowExtendingLine: true,\n            removeOnClick: true,\n            ...options\n        };\n    }\n\n    addHooks() {\n        this._map.on(\"layeradd\", this.handleLayerAdd);\n        this._map.on(\"layerremove\", this.handleLayerRemove);\n\n        this._map.eachLayer((layer) => { this.handleLayerAdd({ layer }); });\n    }\n\n    removeHooks() {\n        this._map.on(\"layeradd\", this.handleLayerAdd);\n        this._map.on(\"layerremove\", this.handleLayerRemove);\n\n        this._map.eachLayer((layer) => { this.handleLayerRemove({ layer }); });\n    }\n\n    handleLayerAdd = (e: { layer: Layer }) => {\n        if (e.layer instanceof Polyline && (typeof this.options.enableForLayer === \"function\" ? this.options.enableForLayer!(e.layer) : this.options.enableForLayer))\n            this.enableForLayer(e.layer as Polyline);\n    };\n\n    handleLayerRemove = (e: { layer: Layer }) => {\n        if (e.layer instanceof Polyline)\n            this.disableForLayer(e.layer as Polyline);\n    };\n\n    handleLayerMouseOver = (e: LeafletMouseEvent) => {\n        if (Draggable._dragging)\n            return;\n\n        this.drawTempMarker(e.target as Polyline, e.latlng);\n    };\n\n    handleLayerSetLatLngs = (e: LeafletEvent) => {\n        const layer = e.target as Polyline;\n        if (!Draggable._dragging) {\n            this.removeTempMarker();\n\n            if (layer._draggableLines) {\n                this.drawDragMarkers(layer);\n                this.drawPlusMarkers(layer);\n            }\n        }\n    };\n\n    drawDragMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n\n        this.removeDragMarkers(layer);\n        \n        const latlngs = layer.getDraggableLinesRoutePoints() || (layer.getLatLngs() as LatLng[] | LatLng[][]);\n        const routePoints = LineUtil.isFlat(latlngs) ? [latlngs] : latlngs;\n        const isFlat = LineUtil.isFlat(latlngs);\n        for (let i = 0; i < routePoints.length; i++) {\n            for (let j = 0; j < routePoints[i].length; j++) {\n                const idx = isFlat ? j : [i, j] as [number, number];\n\n                let removeOnClick = this.options.removeOnClick!;\n                const options = this.options.dragMarkerOptions!(layer, j, routePoints[i].length);\n                const marker = new DraggableLinesDragMarker(this, layer, routePoints[i][j], idx, options, removeOnClick).addTo(this._map);\n                layer._draggableLines.dragMarkers.push(marker);\n\n                marker.on(\"mouseover\", () => {\n                    this.fire(\"dragmouseover\", { layer, idx, marker });\n                });\n                marker.on(\"mouseout\", () => {\n                    this.fire(\"dragmouseout\", { layer, idx, marker });\n                });\n            }\n        }\n    }\n\n    removeDragMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n        \n        for (const marker of layer._draggableLines.dragMarkers) {\n            marker.removeFrom(this._map);\n        }\n        layer._draggableLines.dragMarkers = [];\n    }\n\n    drawPlusMarkers(layer: Polyline) {\n        this.removePlusMarkers(layer);\n\n        if (layer instanceof Polygon || !layer._draggableLines || !this.options.allowExtendingLine)\n            return;\n\n        const latlngs = layer.getLatLngs() as LatLng[] | LatLng[][];\n        const trackPoints = LineUtil.isFlat(latlngs) ? [latlngs] : latlngs;\n        const routePoints = layer.getDraggableLinesRoutePoints();\n        \n        for (let i = 0; i < trackPoints.length; i++) {\n            if (trackPoints[i].length < 2)\n                continue;\n\n            for (const isStart of [true, false]) {\n                let idx: number | [number, number];\n                if (routePoints)\n                    idx = isStart ? 0 : routePoints.length;\n                else if (LineUtil.isFlat(latlngs))\n                    idx = isStart ? 0 : trackPoints[i].length;\n                else\n                    idx = isStart ? [i, 0] : [i, trackPoints[i].length];\n                \n                const options = this.options.plusMarkerOptions!(layer, isStart);\n                const tempMarkerOptions = this.options.plusTempMarkerOptions!(layer, isStart);\n                const marker = new DraggableLinesPlusMarker(this, layer, getPlusIconPoint(this._map, trackPoints[i], 24 + layer.options.weight! / 2, isStart), idx, options, tempMarkerOptions).addTo(this._map);\n                layer._draggableLines.plusMarkers.push(marker);\n            }\n        }\n    }\n\n    removePlusMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n        \n        for (const marker of layer._draggableLines.plusMarkers) {\n            marker.removeFrom(this._map);\n        }\n        layer._draggableLines.plusMarkers = [];\n    }\n\n    drawTempMarker(layer: Polyline, latlng: LatLng) {\n        this.removeTempMarker();\n\n        const options = this.options.tempMarkerOptions!(layer);\n        this._tempMarker = new DraggableLinesTempMarker(this, layer, GeometryUtil.closest(this._map, layer, latlng)!, options).addTo(this._map);\n    }\n\n    removeTempMarker() {\n        if (this._tempMarker) {\n            this._tempMarker.removeFrom(this._map);\n            delete this._tempMarker;\n        }\n    }\n\n    enableForLayer(layer: Polyline) {\n        if (layer._draggableLines)\n            return;\n\n        layer._draggableLines = {\n            dragMarkers: [],\n            plusMarkers: [],\n            zoomEndHandler: () => {\n                this.drawPlusMarkers(layer);\n            }\n        };\n        layer.on(\"mouseover\", this.handleLayerMouseOver);\n        layer.on(\"draggableLines-setLatLngs\", this.handleLayerSetLatLngs);\n        layer.on(\"draggableLines-setRoutePoints\", this.handleLayerSetLatLngs);\n        this._map.on(\"zoomend\", layer._draggableLines.zoomEndHandler);\n        this.drawDragMarkers(layer);\n        this.drawPlusMarkers(layer);\n    }\n\n    redrawForLayer(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n\n        this.drawDragMarkers(layer);\n        this.drawPlusMarkers(layer);\n\n        if (this._tempMarker && this._tempMarker._layer === layer)\n            this.drawTempMarker(layer, this._tempMarker.getLatLng());\n    }\n\n    disableForLayer(layer: Polyline) {\n        layer.off(\"mouseover\", this.handleLayerMouseOver);\n        layer.off(\"draggableLines-setLatLngs\", this.handleLayerSetLatLngs);\n        layer.off(\"draggableLines-setRoutePoints\", this.handleLayerSetLatLngs);\n        if (layer._draggableLines)\n            this._map.off(\"zoomend\", layer._draggableLines.zoomEndHandler);\n        this.removeDragMarkers(layer);\n        this.removePlusMarkers(layer);\n        delete layer._draggableLines;\n    }\n\n    redraw() {\n        this._map.eachLayer((layer) => {\n            if (!(layer instanceof Polyline))\n                return;\n\n            const enable = typeof this.options.enableForLayer === \"function\" ? this.options.enableForLayer(layer) : this.options.enableForLayer;\n            if (layer._draggableLines && !enable)\n                this.disableForLayer(layer);\n            else if (!layer._draggableLines && enable)\n                this.enableForLayer(layer);\n            else if (layer._draggableLines)\n                this.redrawForLayer(layer);\n        });\n    }\n\n}\n\nexport default interface DraggableLinesHandler extends Evented {}\nObject.assign(DraggableLinesHandler.prototype, Evented.prototype);\n","import L from 'leaflet';\nimport DraggableLinesHandler from './handler';\nimport './injections';\nimport * as utils from './utils';\nimport * as icons from './markers/icons';\nimport DraggableLinesMarker from './markers/marker';\nimport DraggableLinesDragMarker from './markers/dragMarker';\nimport DraggableLinesTempMarker from './markers/tempMarker';\nimport DraggableLinesPlusMarker from './markers/plusMarker';\n\nexport * from './utils';\nexport * from './markers/icons';\nexport { DraggableLinesMarker, DraggableLinesDragMarker, DraggableLinesTempMarker, DraggableLinesPlusMarker };\n\ntype DraggableLinesType = typeof DraggableLinesHandler;\n\ndeclare module \"leaflet\" {\n    let DraggableLines: DraggableLinesType\n        & typeof utils\n        & {\n            icons: typeof icons;\n            Marker: typeof DraggableLinesMarker;\n            DragMarker: typeof DraggableLinesDragMarker;\n            TempMarker: typeof DraggableLinesTempMarker;\n            PlusMarker: typeof DraggableLinesPlusMarker;\n        };\n}\n\nL.DraggableLines = Object.assign(DraggableLinesHandler, {\n    ...utils,\n    icons,\n    Marker: DraggableLinesMarker,\n    DragMarker: DraggableLinesDragMarker,\n    TempMarker: DraggableLinesTempMarker,\n    PlusMarker: DraggableLinesPlusMarker\n});\n\nexport default DraggableLinesHandler;","import { latLng, LatLngExpression, Marker, Polyline } from \"leaflet\";\n\nPolyline.prototype.hasDraggableLinesRoutePoints = function() {\n    return this.options.draggableLinesRoutePoints != null;\n};\n\nPolyline.prototype.getDraggableLinesRoutePoints = function() {\n    return this.options.draggableLinesRoutePoints?.map((p) => latLng(p));\n};\n\nPolyline.prototype.setDraggableLinesRoutePoints = function(routePoints: LatLngExpression[] | undefined) {\n    this.options.draggableLinesRoutePoints = routePoints;\n    this.fire('draggableLines-setRoutePoints');\n};\n\nconst setLatLngsBkp = Polyline.prototype.setLatLngs;\nPolyline.prototype.setLatLngs = function(...args: any) {\n    const result = setLatLngsBkp.apply(this, args);\n    this.fire('draggableLines-setLatLngs');\n    return result;\n};\n\ninterface PolylineInfo {\n    dragMarkers: Marker[];\n    plusMarkers: Marker[];\n    zoomEndHandler: () => void;\n}\n\ndeclare module \"leaflet\" {\n    interface Polyline {\n        hasDraggableLinesRoutePoints: () => boolean;\n        getDraggableLinesRoutePoints: () => LatLng[] | undefined;\n        setDraggableLinesRoutePoints: (routePoints: LatLngExpression[] | undefined) => void;\n    }\n\n    interface PolylineOptions {\n        draggableLinesRoutePoints?: LatLngExpression[];\n    }\n\n    interface Polyline {\n        _draggableLines?: PolylineInfo;\n    }\n}","import { Icon, LatLng, LatLngExpression, Map, MarkerOptions, Polygon, Polyline } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { removePoint } from \"../utils\";\nimport DraggableLinesMarker from \"./marker\";\n\nexport default class DraggableLinesDragMarker extends DraggableLinesMarker {\n\n    _idx: number | [number, number];\n    _removeOnClick: boolean;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, idx: number | [number, number], options: MarkerOptions, removeOnClick: boolean) {\n        super(draggable, layer, latlng, false, {\n            draggable: true,\n            ...options\n        });\n\n        this._idx = idx;\n        this._removeOnClick = removeOnClick;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        const latlngs = this._layer.getDraggableLinesRoutePoints() || (this._layer.getLatLngs() as LatLng[] | LatLng[][]);\n        const points = Array.isArray(this._idx) ? (latlngs as LatLng[][])[this._idx[0]] : (latlngs as LatLng[]);\n\n        if (this._removeOnClick && points.length > (this._layer instanceof Polygon ? 3 : 2)) {\n            this.on('click', this.handleClick);\n        }\n\n        return this;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    handleClick() {\n        const idx = this.getIdx();\n\n        removePoint(this._layer, idx);\n        // Markers are redrawn automatically because we update the line points\n\n        this._draggable.fire('remove', { layer: this._layer, idx });\n    }\n\n}\n","import { Icon } from 'leaflet';\nimport defaultIconDataUrl from './marker.svg';\nimport plusIconDataUrl from './plus.svg';\n\nconst imagePath = (Icon.Default.prototype as any)._detectIconPath();\nfunction createIcon(colors: Record<string, string>) {\n    let url = defaultIconDataUrl;\n    for (const key of Object.keys(colors)) {\n        url = url.replace(new RegExp(`%24%7b${key}%7d`, 'g'), encodeURIComponent(colors[key]))\n    }\n    return new Icon.Default({ imagePath: new String('') as string, iconUrl: url, iconRetinaUrl: url, shadowUrl: `${imagePath}marker-shadow.png` }) as Icon;\n}\n\nexport const defaultIcon = createIcon({ color1: \"#2e6c97\", color2: \"#3883b7\", color3: \"#126fc6\", color4: \"#4c9cd1\" });\nexport const startIcon = createIcon({ color1: \"#2E9749\", color2: \"#06EA3F\", color3: \"#03D337\", color4: \"#40DD68\" });\nexport const endIcon = createIcon({ color1: \"#972E2E\", color2: \"#B73838\", color3: \"#C61212\", color4: \"#D14C4C\" });\n\nexport const plusIcon = new Icon({\n    iconUrl: plusIconDataUrl,\n    iconSize: [24, 24],\n    iconAnchor: [12, 12]\n});","import { LatLng, LatLngExpression, LeafletEvent, Map, Marker, MarkerOptions, Polyline } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { setPoint } from \"../utils\";\n\nexport default abstract class DraggableLinesMarker extends Marker {\n\n    _draggable: DraggableLinesHandler;\n    _layer: Polyline;\n    _isInsert: boolean;\n\n    _dragIdx?: number | [number, number];\n    _dragFrom?: LatLng;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, isInsert: boolean, options?: MarkerOptions) {\n        super(latlng, options);\n\n        this._draggable = draggable;\n        this._layer = layer;\n        this._isInsert = isInsert;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        this.on(\"dragstart\", this.handleDragStart, this);\n        this.on(\"drag\", this.handleDrag, this);\n        this.on(\"dragend\", this.handleDragEnd, this);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        super.onRemove(map);\n\n        return this;\n    }\n\n    abstract getIdx(): number | [number, number];\n\n    handleDragStart(e: LeafletEvent) {\n        const latlng = this.getLatLng();\n        this._dragFrom = latlng;\n        this._dragIdx = this.getIdx();\n\n        setPoint(this._layer, latlng, this._dragIdx, this._isInsert);\n\n        this._draggable.fire('dragstart', { layer: this._layer, from: latlng, to: latlng, idx: this._dragIdx, isNew: this._isInsert });\n    };\n\n    handleDrag() {\n        const latlng = this.getLatLng();\n\n        setPoint(this._layer, latlng, this._dragIdx!, false);\n\n        this._draggable.fire('drag', { layer: this._layer, from: this._dragFrom!, to: latlng, idx: this._dragIdx!, isNew: this._isInsert });\n    }\n\n    handleDragEnd() {\n        const event = { layer: this._layer, from: this._dragFrom!, to: this.getLatLng(), idx: this._dragIdx!, isNew: this._isInsert };\n\n        Promise.resolve().then(() => {\n            // Set points on the next tick so that Dragging._draggable is unset and DraggableLinesHandler reacts to the route point update\n            // and rerenders the markers.\n            setPoint(event.layer, event.to, event.idx, false);\n            this._draggable.fire('dragend', event);\n        });\n    };\n\n}\n","import { DomUtil, LatLng, LatLngExpression, LeafletMouseEvent, Map, MarkerOptions, Polyline } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport DraggableLinesMarker from \"./marker\";\nimport DraggableLinesTempMarker from \"./tempMarker\";\n\nexport default class DraggableLinesPlusMarker extends DraggableLinesMarker {\n\n    _idx: number | [number, number];\n    _tempMarker?: DraggableLinesPlusTempMarker;\n    _tempMarkerOptions: MarkerOptions;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, idx: number | [number, number], options: MarkerOptions, tempMarkerOptions: MarkerOptions) {\n        super(draggable, layer, latlng, true, {\n            pane: \"overlayPane\",\n            zIndexOffset: -200000,\n            ...options\n        });\n\n        this._idx = idx;\n        this._tempMarkerOptions = tempMarkerOptions;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        this.on('mouseover', this.handleMouseOver, this);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        super.onRemove(map);\n\n        if (this._tempMarker) {\n            this._tempMarker.remove();\n            delete this._tempMarker;\n        }\n        \n        return this;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    handleMouseOver(e: LeafletMouseEvent) {\n        this._draggable.removeTempMarker();\n\n        this._tempMarker = new DraggableLinesPlusTempMarker(this._draggable, this._layer, this, e.latlng, this.getIdx(), this._tempMarkerOptions).addTo(this._map)\n        this._draggable._tempMarker = this._tempMarker;\n    }\n\n}\n\nclass DraggableLinesPlusTempMarker extends DraggableLinesTempMarker {\n    \n    _plusMarker: DraggableLinesPlusMarker;\n    _idx: number | [number, number];\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, plusMarker: DraggableLinesPlusMarker, latlng: LatLngExpression, idx: number | [number, number], options: MarkerOptions) {\n        super(draggable, layer, latlng, options);\n\n        this._plusMarker = plusMarker;\n        this._idx = idx;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    shouldRemove(latlng: LatLng) {\n        const layerPoint = this._map.latLngToLayerPoint(latlng);\n        const position = DomUtil.getPosition(this._plusMarker._icon);\n        return Math.abs(position.y - layerPoint.y) > this._plusMarker._icon.offsetHeight / 2\n            || Math.abs(position.x - layerPoint.x) > this._plusMarker._icon.offsetWidth / 2;\n    }\n\n    getRenderPoint() {\n        return this.getLatLng();\n    }\n\n}","import { DivIcon, DomEvent, Draggable, GeometryUtil, Icon, latLng, LatLng, LatLngExpression, LeafletMouseEvent, Map, MarkerOptions, Polygon, Polyline, Util } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { getInsertPosition, getRouteInsertPosition, setPoint } from \"../utils\";\nimport DraggableLinesMarker from \"./marker\";\n\nfunction createIcon(layer: Polyline, baseIcon: Icon | DivIcon) {\n    const icon = Util.create(baseIcon);\n    const _setIconStyles = icon._setIconStyles;\n    icon._setIconStyles = (img: HTMLImageElement, name: string) => {\n        _setIconStyles.call(icon, img, name);\n\n        // Create a padding around the marker to make sure that we don't accidentally trigger an unwanted mouseout\n        // event while hovering around on the line.\n        const padding = layer.options.weight! * 2;\n        img.style.padding = `${padding}px`;\n        img.style.marginLeft = `${parseInt(img.style.marginLeft) - padding}px`;\n        img.style.marginTop = `${parseInt(img.style.marginTop) - padding}px`;\n    };\n    return icon;\n}\n\nexport default class DraggableLinesTempMarker extends DraggableLinesMarker {\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, options: MarkerOptions) {\n        super(draggable, layer, latlng, true, {\n            draggable: true,\n            zIndexOffset: -100000,\n            ...options,\n            icon: createIcon(layer, options.icon!)\n        });\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        map.on(\"mousemove\", this.handleMapMouseMove, this);\n        DomEvent.on(map.getContainer(), \"mouseover\", this.handleMapMouseOver, this); // Bind manually since map.on(\"mouseover\") does not receive bubbling events\n        this.on('click', this.handleClick, this);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        super.onRemove(map);\n\n        map.off(\"mousemove\", this.handleMapMouseMove, this);\n        DomEvent.off(map.getContainer(), \"mouseover\", this.handleMapMouseOver, this);\n\n        return this;\n    }\n\n    show() {\n        this._icon.style.display = '';\n        if (this._shadow)\n            this._shadow.style.display = '';\n    }\n\n    hide() {\n        this._icon.style.display = 'none';\n        if (this._shadow)\n            this._shadow.style.display = 'none';\n    }\n\n    isHidden() {\n        return this._icon.style.display == 'none';\n    }\n\n    getIdx() {\n        const latlng = this.getLatLng();\n        if (this._layer.hasDraggableLinesRoutePoints())\n            return getRouteInsertPosition(this._map, this._layer.getDraggableLinesRoutePoints()!, this._layer.getLatLngs() as any, latlng);\n        else\n            return getInsertPosition(this._map, this._layer.getLatLngs() as LatLng[] | LatLng[][], latlng, this._layer instanceof Polygon);\n    }\n\n\n    handleClick() {\n        const latlng = this.getLatLng();\n        const idx = this.getIdx();\n\n        setPoint(this._layer, latlng, idx, true);\n\n        this._draggable.fire('insert', { layer: this._layer, latlng, idx });\n    }\n\n\n    shouldRemove(latlng: LatLng) {\n        return !this._layer._containsPoint(this._map.latLngToLayerPoint(latlng));\n    }\n\n\n    getRenderPoint(latlng: LatLng): LatLng | undefined {\n        const closest = GeometryUtil.closest(this._map, this._layer, latlng)!;\n\n        // In case of a polygon, we want to hide the marker while we are hovering the fill, we only want to show\n        // it while we are hovering the outline.\n        if (closest.distance > this._layer.options.weight! / 2 + 1)\n            return undefined;\n        \n        return latLng(closest);\n    }\n\n\n    handleMapMouseMove(e: LeafletMouseEvent) {\n        if (Draggable._dragging)\n            return;\n\n        if (this.shouldRemove(this._map.mouseEventToLatLng(e.originalEvent))) {\n            this.remove();\n            return;\n        }\n\n        const latlng = this.getRenderPoint(this._map.mouseEventToLatLng(e.originalEvent));\n\n        if (latlng)\n            this.setLatLng(latlng);\n\n        const isVisible = !this.isHidden();\n        if (latlng && !isVisible)\n            this.show();\n        else if (!latlng && isVisible)\n            this.hide();\n    };\n\n\n    handleMapMouseOver(e: Event) {\n        if (!Draggable._dragging && e.target !== this.getElement() && e.target !== this._layer.getElement())\n            this.remove();\n    };\n\n}","import L, { LatLng, LineUtil, Map, Polyline } from \"leaflet\";\nimport GeometryUtil from \"leaflet-geometryutil\";\n\nexport type PolylineIndex = number | [number, number];\n\n/**\n * If `points` is the array of coordinates or array of arrays of coordinates that a Polyline/Polygon consists of and `point` is the\n * coordinates where the dragging starts, this method returns the index in the `points` array where the new point should be inserted.\n * The returned value is a number of a tuple of two numbers, depending on whether `points` is an array or an array of arrays.\n *\n * @param map: The instance of `L.Map`.\n * @param points: An array of coordinates or array of arrays of coordinates as returned by `layer.getLatLngs()`.\n * @param point: An instance of `L.LatLng` that represents the point on the line where dragging has started.\n * @param allowExtendingLine: If `true` (default), will return `0` or `points.length` if the dragging has started before the beginning\n * or after the end of the line. If `false`, will always return at least `1` and at most `points.length - 1` to prevent the\n * beginning/end of the line to be modified. Has no effect if `isPolygon` is `true`.\n * @param isPolygon: If `true`, `points` will be considered to be the coordinates of a polygon, if `false` (default), it will be considered\n * the coordinates of a line. The difference between a polygon and a line is that in a polygon, the first point and the last point\n * of the coordinates listed in `points` are connected by an additional segment that can also be dragged.\n */\nexport function getInsertPosition(map: Map, points: LatLng[], point: LatLng, isPolygon?: boolean): number;\nexport function getInsertPosition(map: Map, points: LatLng[][], point: LatLng, isPolygon?: boolean): [number, number];\nexport function getInsertPosition(map: Map, points: LatLng[] | LatLng[][], point: LatLng, isPolygon?: boolean): number | [number, number];\nexport function getInsertPosition(map: Map, points: LatLng[] | LatLng[][], point: LatLng, isPolygon = false): number | [number, number] {\n    if (!LineUtil.isFlat(points)) {\n        // In case of a multi polyline/polygon, we need to figure out first which one of the polylines/polygons the closest point is on.\n        // GeometryUtil.closest() doesn't seem to tell us that, so we need to check the distance to each sub polyline/polygon manually.\n        // Internally, GeometryUtil.closest() seems to do it the same way.\n        let result: { distance: number, i: number } | undefined;\n        for (let i = 0; i < points.length; i++) {\n            const polyline = isPolygon ? L.polygon(points[i]) : L.polyline(points[i]);\n            const distance = GeometryUtil.closest(map, polyline, point)!.distance;\n            if (!result || distance < result.distance) {\n                result = { distance, i };\n            }\n        }\n        return result ? [result.i, getInsertPosition(map, points[result.i], point, isPolygon)] : [0, 0];\n    }\n\n    const polyline = L.polyline(isPolygon ? [...points, points[0]] : points);\n    const pos = GeometryUtil.locateOnLine(map, polyline, point);\n    const before = L.GeometryUtil.extract(map, polyline, 0, pos);\n    \n    let idx = before.length - 1;\n    if (!isPolygon)\n        idx = Math.max(1, Math.min(points.length - 1, idx));\n    return idx;\n}\n\n\n/**\n * Similar to `getInsertPosition`, but for a line where the points returned by `getLatLngs()` (“track points”) are a route that has been\n * calculated to be the best connection between a set of waypoints (“route points”). Dragging starts on a segment between two track\n * points, but should lead an additional point in the set of route points rather than track points, so that the route can be recalculated.\n * This method returns the index where the new route point should be inserted into the array of route points.\n * @param map: The instance of `L.Map`.\n * @param routePoints: An array of coordinates that are the waypoints that are used as the basis for calculating the route.\n * @param trackPoints: An array of coordinates as returned by `layer.getLatLngs()`.\n * @param point: An instance of `L.LatLng` that represents the point on the line where dragging has started.\n */\nexport function getRouteInsertPosition(map: Map, routePoints: LatLng[], trackPoints: LatLng[], point: LatLng): number {\n    const polyline = L.polyline(trackPoints);\n    const pos = GeometryUtil.locateOnLine(map, polyline, point);\n\n    for (let i = 0; i < routePoints.length; i++) {\n        if (GeometryUtil.locateOnLine(map, polyline, routePoints[i]) > pos)\n            return i;\n    }\n    return routePoints.length;\n}\n\nexport function getFromPosition<T, A extends T[] | T[][]>(arr: A, idx: PolylineIndex): T {\n    return Array.isArray(idx) ? (arr as any)[idx[0]][idx[1]] : arr[idx];\n}\n\n/**\n * Returns a copy of the `arr` array with `item` inserted at the index `idx`. `arr` can be an array or an array of arrays (as\n * returned by `getLatLngs()` on a Polyline/Polygon), and `idx` can be a number or a tuple of two numbers as returned by\n * `L.DraggableLines.getInsertPosition()` (and as passed along with the drag events). This method can be used to easily insert\n * a new point at the right position.\n */\nexport function insertAtPosition<T, A extends T[] | T[][]>(arr: A, item: T, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), item, ...arr.slice(idxArr[0])] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = insertAtPosition(result[idxArr[0]] as any, item, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\n/**\n * Like `L.DraggableLines.insertAtPosition`, but overwrites the item at the given index instead of inserting it there.\n * \n * Returns a copy of the `arr` array with the item at index `idx` overwritten with `item`. `arr` can be an array or an array\n * of arrays (as returned by `getLatLngs()` on a Polyline/Polygon), and `idx` can be a number or a tuple of two numbers as\n * returned by `L.DraggableLines.getInsertPosition()` (and as passed along with the drag events). This method can be used\n * to easily update a new point at the right position while the user is dragging:\n */\nexport function updateAtPosition<T, A extends T[] | T[][]>(arr: A, item: T, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), item, ...arr.slice(idxArr[0] + 1)] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = updateAtPosition(result[idxArr[0]] as any, item, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\nexport function removeFromPosition<A extends any[] | any[][]>(arr: A, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), ...arr.slice(idxArr[0] + 1)] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = removeFromPosition(result[idxArr[0]] as any, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\nexport function setPoint(layer: Polyline, point: LatLng, idx: number | [number, number], insert: boolean) {\n    const hasRoutePoints = layer.hasDraggableLinesRoutePoints();\n    \n    let points = hasRoutePoints ? layer.getDraggableLinesRoutePoints()! : layer.getLatLngs() as LatLng[] | LatLng[][];\n    \n    if (insert)\n        points = insertAtPosition(points, point, idx);\n    else\n        points = updateAtPosition(points, point, idx);\n    \n    if (hasRoutePoints)\n        layer.setDraggableLinesRoutePoints(points as any);\n    else\n        layer.setLatLngs(points);\n}\n\nexport function removePoint(layer: Polyline, idx: number | [number, number]) {\n    const hasRoutePoints = layer.hasDraggableLinesRoutePoints();\n    \n    let points = hasRoutePoints ? layer.getDraggableLinesRoutePoints()! : layer.getLatLngs() as LatLng[] | LatLng[][];\n    points = removeFromPosition(points, idx);\n\n    if (hasRoutePoints)\n        layer.setDraggableLinesRoutePoints(points as any);\n    else\n        layer.setLatLngs(points);\n}\n\nexport function getPlusIconPoint(map: Map, trackPoints: LatLng[], distance: number, atStart: boolean) {\n    const tr = atStart ? trackPoints : [...trackPoints].reverse();\n\n    const point0 = map.latLngToContainerPoint(tr[0]);\n    const point1 = map.latLngToContainerPoint(tr[1]);\n\n    const fraction = distance / point0.distanceTo(point1);\n    const result = L.point(point0.x - fraction * (point1.x - point0.x), point0.y - fraction * (point1.y - point0.y));\n    return map.containerPointToLatLng(result);\n}","export default \"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='25.1' height='40.227'%3e %3cdefs%3e %3clinearGradient id='b'%3e %3cstop offset='0' stop-color='%24%7bcolor1%7d' /%3e %3cstop offset='1' stop-color='%24%7bcolor2%7d' /%3e %3c/linearGradient%3e %3clinearGradient id='a'%3e %3cstop offset='0' stop-color='%24%7bcolor3%7d' /%3e %3cstop offset='1' stop-color='%24%7bcolor4%7d' /%3e %3c/linearGradient%3e %3clinearGradient xlink:href='%23a' id='c' gradientUnits='userSpaceOnUse' gradientTransform='translate(-432.796 -503.349)' x1='445.301' y1='541.286' x2='445.301' y2='503.72' /%3e %3clinearGradient xlink:href='%23b' id='d' gradientUnits='userSpaceOnUse' gradientTransform='translate(-341.216 -503.35)' x1='351.748' y1='522.774' x2='351.748' y2='503.721' /%3e %3c/defs%3e %3cpath fill='white' d='M6.329 4.513h12.625v14.5H6.329z' /%3e %3cpath d='M12.594.55C6.021.55.55 6.241.55 12.416c0 2.778 1.564 6.308 2.694 8.746l9.306 17.872 9.262-17.872c1.13-2.438 2.738-5.791 2.738-8.746C24.55 6.241 19.167.55 12.594.55zm0 7.155a4.714 4.714 0 0 1 4.679 4.71c0 2.588-2.095 4.663-4.679 4.679-2.584-.017-4.679-2.09-4.679-4.679a4.714 4.714 0 0 1 4.679-4.71z' fill='url(%23c)' stroke='url(%23d)' stroke-width='1.1' stroke-linecap='round' /%3e %3cpath d='M12.581 1.657c-5.944 0-10.938 5.219-10.938 10.75 0 2.359 1.443 5.832 2.563 8.25l.031.031 8.313 15.969 8.25-15.969.031-.031c1.135-2.448 2.625-5.706 2.625-8.25 0-5.538-4.931-10.75-10.875-10.75zm0 4.969c3.168.021 5.781 2.601 5.781 5.781 0 3.18-2.613 5.761-5.781 5.781-3.168-.02-5.75-2.61-5.75-5.781 0-3.172 2.582-5.761 5.75-5.781z' stroke='white' stroke-width='1.1' stroke-linecap='round' stroke-opacity='.122' fill='none' /%3e %3c/svg%3e\"","export default \"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24'%3e %3cg transform='matrix(.02604 0 0 .02604 1.302 1.302)' fill='none' stroke='black' opacity='0.3'%3e %3ccircle cx='410.9' cy='410.9' r='410.9' color='black' overflow='visible' stroke-width='100' /%3e %3cpath d='M410.9 223.2v375.4M598.6 410.9H223.2' stroke-width='120' stroke-linecap='round' /%3e %3c/g%3e %3c/svg%3e\"","module.exports = __WEBPACK_EXTERNAL_MODULE__453__;","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(607);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}