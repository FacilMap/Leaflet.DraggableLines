{"version":3,"sources":["webpack://L.DraggableLines/webpack/universalModuleDefinition","webpack://L.DraggableLines/./src/handler.ts","webpack://L.DraggableLines/./src/index.ts","webpack://L.DraggableLines/./src/injections.ts","webpack://L.DraggableLines/./src/markers/dragMarker.ts","webpack://L.DraggableLines/./src/markers/icons.ts","webpack://L.DraggableLines/./src/markers/marker.ts","webpack://L.DraggableLines/./src/markers/plusMarker.ts","webpack://L.DraggableLines/./src/markers/tempMarker.ts","webpack://L.DraggableLines/./src/utils.ts","webpack://L.DraggableLines/external {\"commonjs\":\"leaflet\",\"commonjs2\":\"leaflet\",\"amd\":\"leaflet\",\"root\":\"L\"}","webpack://L.DraggableLines/external {\"commonjs\":\"leaflet-geometryutil\",\"commonjs2\":\"leaflet-geometryutil\",\"amd\":\"leaflet-geometryutil\",\"root\":[\"L\",\"GeometryUtil\"]}","webpack://L.DraggableLines/webpack/bootstrap","webpack://L.DraggableLines/webpack/startup"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__453__","__WEBPACK_EXTERNAL_MODULE__7__","map","options","handleLayerAdd","e","layer","Polyline","shouldEnableForLayer","enableForLayer","handleLayerRemove","disableForLayer","handleLayerMouseOver","Draggable","_dragging","drawTempMarker","target","latlng","handleLayerSetLatLngs","removeTempMarker","_draggableLines","drawDragMarkers","drawPlusMarkers","interactive","allowExtendingLine","removeOnClick","addHooks","this","_map","on","eachLayer","removeHooks","Array","isArray","includes","removeDragMarkers","latlngs","getDraggableLinesRoutePoints","getLatLngs","routePoints","LineUtil","isFlat","i","length","j","idx","icon","Polygon","defaultIcon","startIcon","endIcon","dragMarkerOptions","marker","addTo","dragMarkers","push","removeFrom","removePlusMarkers","trackPoints","isStart","plusIcon","plusMarkerOptions","tempMarkerOptions","plusTempMarkerOptions","getPlusIconPoint","weight","plusMarkers","_tempMarker","closest","zoomEndHandler","redrawForLayer","_layer","getLatLng","off","redraw","enable","Handler","Object","assign","DraggableLinesHandler","prototype","Evented","DraggableLinesMarker","DraggableLinesDragMarker","DraggableLinesTempMarker","DraggableLinesPlusMarker","DraggableLines","utils","icons","Marker","DragMarker","TempMarker","PlusMarker","PlusTempMarker","DraggableLinesPlusTempMarker","hasDraggableLinesRoutePoints","draggableLinesRoutePoints","p","latLng","setDraggableLinesRoutePoints","fire","setLatLngsBkp","setLatLngs","result","apply","args","draggable","_idx","_removeOnClick","onAdd","points","handleClick","_draggable","getIdx","removePoint","createIcon","colors","url","default","keys","key","replace","RegExp","encodeURIComponent","Icon","Default","imagePath","String","iconUrl","iconRetinaUrl","shadowUrl","color1","color2","color3","color4","iconSize","iconAnchor","isInsert","_isInsert","handleDragStart","handleDrag","handleDragEnd","onRemove","_dragFrom","_dragIdx","setPoint","from","to","isNew","event","Promise","resolve","then","pane","zIndexOffset","_tempMarkerOptions","handleMouseOver","remove","plusMarker","_plusMarker","shouldRemove","layerPoint","latLngToLayerPoint","position","DomUtil","getPosition","_icon","Math","abs","y","offsetHeight","x","offsetWidth","getRenderPoint","fireMouseOver","fireMouseMove","fireMouseOut","baseIcon","Util","create","_setIconStyles","img","name","call","padding","style","boxSizing","marginLeft","parseInt","marginTop","handleMapMouseMove","DomEvent","getContainer","handleMapMouseOver","isHidden","show","display","_shadow","hide","getRouteInsertPosition","getInsertPosition","_containsPoint","GeometryUtil","distance","mouseEventToLatLng","originalEvent","setLatLng","isVisible","getElement","insertAtPosition","arr","item","idxArr","slice","updateAtPosition","removeFromPosition","point","isPolygon","polygon","polyline","pos","locateOnLine","extract","max","min","insert","hasRoutePoints","atStart","tr","reverse","point0","latLngToContainerPoint","tr1","find","distanceTo","point1","fraction","containerPointToLatLng","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"mappings":"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","file":"L.DraggableLines.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"leaflet\"), require(\"leaflet-geometryutil\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"leaflet\", \"leaflet-geometryutil\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"L\"] = factory(require(\"leaflet\"), require(\"leaflet-geometryutil\"));\n\telse\n\t\troot[\"L\"] = root[\"L\"] || {}, root[\"L\"][\"DraggableLines\"] = factory(root[\"L\"], root[\"L\"][\"GeometryUtil\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__453__, __WEBPACK_EXTERNAL_MODULE__7__) {\nreturn ","import L, { Draggable, Evented, Handler, Icon, LatLng, Layer, LeafletEvent, LeafletMouseEvent, LineUtil, Map, Marker, MarkerOptions, Polygon, Polyline } from 'leaflet';\nimport GeometryUtil from 'leaflet-geometryutil';\nimport { defaultIcon, endIcon, plusIcon, startIcon } from './markers/icons';\nimport DraggableLinesDragMarker from './markers/dragMarker';\nimport DraggableLinesPlusMarker from './markers/plusMarker';\nimport DraggableLinesTempMarker from './markers/tempMarker';\nimport { getPlusIconPoint } from './utils';\n\nexport interface DraggableLinesHandlerOptions {\n    enableForLayer?: boolean | Polyline | Polyline[] | ((layer: Polyline) => boolean);\n    dragMarkerOptions?: (layer: Polyline, i: number, length: number) => MarkerOptions;\n    tempMarkerOptions?: (layer: Polyline) => MarkerOptions;\n    plusMarkerOptions?: (layer: Polyline, isStart: boolean) => MarkerOptions;\n    plusTempMarkerOptions?: (layer: Polyline, isStart: boolean) => MarkerOptions;\n    allowExtendingLine?: boolean;\n    removeOnClick?: boolean;\n}\n\nexport default class DraggableLinesHandler extends Handler {\n\n    options: DraggableLinesHandlerOptions;\n    \n    _tempMarker?: DraggableLinesTempMarker;\n\n    constructor(map: Map, options?: DraggableLinesHandlerOptions) {\n        super(map);\n\n        this.options = {\n            enableForLayer: (layer) => layer.options.interactive!,\n            allowExtendingLine: true,\n            removeOnClick: true,\n            ...options\n        };\n    }\n\n    addHooks() {\n        this._map.on(\"layeradd\", this.handleLayerAdd);\n        this._map.on(\"layerremove\", this.handleLayerRemove);\n\n        this._map.eachLayer((layer) => { this.handleLayerAdd({ layer }); });\n    }\n\n    removeHooks() {\n        this._map.on(\"layeradd\", this.handleLayerAdd);\n        this._map.on(\"layerremove\", this.handleLayerRemove);\n\n        this._map.eachLayer((layer) => { this.handleLayerRemove({ layer }); });\n    }\n\n    shouldEnableForLayer(layer: Polyline) {\n        if (typeof this.options.enableForLayer === \"function\")\n            return this.options.enableForLayer(layer);\n        else if (typeof this.options.enableForLayer === \"boolean\")\n            return this.options.enableForLayer;\n        else if (Array.isArray(this.options.enableForLayer))\n            return this.options.enableForLayer.includes(layer);\n        else\n            return this.options.enableForLayer === layer;\n    }\n\n    handleLayerAdd = (e: { layer: Layer }) => {\n        if (e.layer instanceof Polyline && this.shouldEnableForLayer(e.layer))\n            this.enableForLayer(e.layer as Polyline);\n    };\n\n    handleLayerRemove = (e: { layer: Layer }) => {\n        if (e.layer instanceof Polyline)\n            this.disableForLayer(e.layer as Polyline);\n    };\n\n    handleLayerMouseOver = (e: LeafletMouseEvent) => {\n        if (Draggable._dragging)\n            return;\n\n        this.drawTempMarker(e.target as Polyline, e.latlng);\n    };\n\n    handleLayerSetLatLngs = (e: LeafletEvent) => {\n        const layer = e.target as Polyline;\n        if (!Draggable._dragging) {\n            this.removeTempMarker();\n\n            if (layer._draggableLines) {\n                this.drawDragMarkers(layer);\n                this.drawPlusMarkers(layer);\n            }\n        }\n    };\n\n    drawDragMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n\n        this.removeDragMarkers(layer);\n        \n        const latlngs = layer.getDraggableLinesRoutePoints() || (layer.getLatLngs() as LatLng[] | LatLng[][]);\n        const routePoints = LineUtil.isFlat(latlngs) ? [latlngs] : latlngs;\n        const isFlat = LineUtil.isFlat(latlngs);\n        for (let i = 0; i < routePoints.length; i++) {\n            for (let j = 0; j < routePoints[i].length; j++) {\n                const idx = isFlat ? j : [i, j] as [number, number];\n\n                let removeOnClick = this.options.removeOnClick!;\n                const options = {\n                    icon: layer instanceof Polygon ? defaultIcon : (j == 0 ? startIcon : j == routePoints[i].length - 1 ? endIcon : defaultIcon),\n                    ...this.options.dragMarkerOptions?.(layer, j, routePoints[i].length)\n                };\n                const marker = new DraggableLinesDragMarker(this, layer, routePoints[i][j], idx, options, removeOnClick).addTo(this._map);\n                layer._draggableLines.dragMarkers.push(marker);\n            }\n        }\n    }\n\n    removeDragMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n        \n        for (const marker of layer._draggableLines.dragMarkers) {\n            marker.removeFrom(this._map);\n        }\n        layer._draggableLines.dragMarkers = [];\n    }\n\n    drawPlusMarkers(layer: Polyline) {\n        this.removePlusMarkers(layer);\n\n        if (layer instanceof Polygon || !layer._draggableLines || !this.options.allowExtendingLine)\n            return;\n\n        const latlngs = layer.getLatLngs() as LatLng[] | LatLng[][];\n        const trackPoints = LineUtil.isFlat(latlngs) ? [latlngs] : latlngs;\n        const routePoints = layer.getDraggableLinesRoutePoints();\n        \n        for (let i = 0; i < trackPoints.length; i++) {\n            if (trackPoints[i].length < 2)\n                continue;\n\n            for (const isStart of [true, false]) {\n                let idx: number | [number, number];\n                if (routePoints)\n                    idx = isStart ? 0 : routePoints.length;\n                else if (LineUtil.isFlat(latlngs))\n                    idx = isStart ? 0 : trackPoints[i].length;\n                else\n                    idx = isStart ? [i, 0] : [i, trackPoints[i].length];\n                \n                const options = {\n                    icon: plusIcon,\n                    ...this.options.plusMarkerOptions?.(layer, isStart)\n                };\n                const tempMarkerOptions = {\n                    icon: isStart ? startIcon : endIcon,\n                    ...this.options.plusTempMarkerOptions?.(layer, isStart)\n                };\n                const marker = new DraggableLinesPlusMarker(this, layer, getPlusIconPoint(this._map, trackPoints[i], 24 + layer.options.weight! / 2, isStart), idx, options, tempMarkerOptions).addTo(this._map);\n                layer._draggableLines.plusMarkers.push(marker);\n            }\n        }\n    }\n\n    removePlusMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n        \n        for (const marker of layer._draggableLines.plusMarkers) {\n            marker.removeFrom(this._map);\n        }\n        layer._draggableLines.plusMarkers = [];\n    }\n\n    drawTempMarker(layer: Polyline, latlng: LatLng) {\n        this.removeTempMarker();\n\n        const options = {\n            icon: defaultIcon,\n            ...this.options.tempMarkerOptions?.(layer)\n        };\n        this._tempMarker = new DraggableLinesTempMarker(this, layer, GeometryUtil.closest(this._map, layer, latlng)!, options).addTo(this._map);\n    }\n\n    removeTempMarker() {\n        if (this._tempMarker) {\n            this._tempMarker.removeFrom(this._map);\n            delete this._tempMarker;\n        }\n    }\n\n    enableForLayer(layer: Polyline) {\n        if (layer._draggableLines)\n            return;\n\n        layer._draggableLines = {\n            dragMarkers: [],\n            plusMarkers: [],\n            zoomEndHandler: () => {\n                this.drawPlusMarkers(layer);\n            }\n        };\n        layer.on(\"mouseover\", this.handleLayerMouseOver);\n        layer.on(\"draggableLines-setLatLngs\", this.handleLayerSetLatLngs);\n        layer.on(\"draggableLines-setRoutePoints\", this.handleLayerSetLatLngs);\n        this._map.on(\"zoomend\", layer._draggableLines.zoomEndHandler);\n        this.drawDragMarkers(layer);\n        this.drawPlusMarkers(layer);\n    }\n\n    redrawForLayer(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n\n        this.drawDragMarkers(layer);\n        this.drawPlusMarkers(layer);\n\n        if (this._tempMarker && this._tempMarker._layer === layer)\n            this.drawTempMarker(layer, this._tempMarker.getLatLng());\n    }\n\n    disableForLayer(layer: Polyline) {\n        layer.off(\"mouseover\", this.handleLayerMouseOver);\n        layer.off(\"draggableLines-setLatLngs\", this.handleLayerSetLatLngs);\n        layer.off(\"draggableLines-setRoutePoints\", this.handleLayerSetLatLngs);\n        if (layer._draggableLines)\n            this._map.off(\"zoomend\", layer._draggableLines.zoomEndHandler);\n        this.removeDragMarkers(layer);\n        this.removePlusMarkers(layer);\n        delete layer._draggableLines;\n    }\n\n    redraw() {\n        this._map.eachLayer((layer) => {\n            if (!(layer instanceof Polyline))\n                return;\n\n            const enable = this.shouldEnableForLayer(layer);\n            if (layer._draggableLines && !enable)\n                this.disableForLayer(layer);\n            else if (!layer._draggableLines && enable)\n                this.enableForLayer(layer);\n            else if (layer._draggableLines)\n                this.redrawForLayer(layer);\n        });\n    }\n\n}\n\nexport default interface DraggableLinesHandler extends Evented {}\nObject.assign(DraggableLinesHandler.prototype, Evented.prototype);\n","import DraggableLinesHandler from './handler';\nimport './injections';\nimport * as utils from './utils';\nimport * as icons from './markers/icons';\nimport DraggableLinesMarker from './markers/marker';\nimport DraggableLinesDragMarker from './markers/dragMarker';\nimport DraggableLinesTempMarker from './markers/tempMarker';\nimport DraggableLinesPlusMarker, { DraggableLinesPlusTempMarker } from './markers/plusMarker';\n\nexport * from './utils';\nexport * from './markers/icons';\nexport { DraggableLinesMarker, DraggableLinesDragMarker, DraggableLinesTempMarker, DraggableLinesPlusMarker };\n\nexport default DraggableLinesHandler;\n\nexport const DraggableLines = Object.assign(DraggableLinesHandler, {\n    ...utils,\n    icons,\n    Marker: DraggableLinesMarker,\n    DragMarker: DraggableLinesDragMarker,\n    TempMarker: DraggableLinesTempMarker,\n    PlusMarker: DraggableLinesPlusMarker,\n    PlusTempMarker: DraggableLinesPlusTempMarker\n});","import { latLng, LatLngExpression, Marker, Polyline } from \"leaflet\";\n\nPolyline.prototype.hasDraggableLinesRoutePoints = function() {\n    return this.options.draggableLinesRoutePoints != null;\n};\n\nPolyline.prototype.getDraggableLinesRoutePoints = function() {\n    return this.options.draggableLinesRoutePoints?.map((p) => latLng(p));\n};\n\nPolyline.prototype.setDraggableLinesRoutePoints = function(routePoints: LatLngExpression[] | undefined) {\n    this.options.draggableLinesRoutePoints = routePoints;\n    this.fire('draggableLines-setRoutePoints');\n};\n\nconst setLatLngsBkp = Polyline.prototype.setLatLngs;\nPolyline.prototype.setLatLngs = function(...args: any) {\n    const result = setLatLngsBkp.apply(this, args);\n    this.fire('draggableLines-setLatLngs');\n    return result;\n};\n\ninterface PolylineInfo {\n    dragMarkers: Marker[];\n    plusMarkers: Marker[];\n    zoomEndHandler: () => void;\n}\n\ndeclare module \"leaflet\" {\n    interface Polyline {\n        hasDraggableLinesRoutePoints: () => boolean;\n        getDraggableLinesRoutePoints: () => LatLng[] | undefined;\n        setDraggableLinesRoutePoints: (routePoints: LatLngExpression[] | undefined) => void;\n    }\n\n    interface PolylineOptions {\n        draggableLinesRoutePoints?: LatLngExpression[];\n    }\n\n    interface Polyline {\n        _draggableLines?: PolylineInfo;\n    }\n}","import { Icon, LatLng, LatLngExpression, Map, MarkerOptions, Polygon, Polyline } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { removePoint } from \"../utils\";\nimport DraggableLinesMarker from \"./marker\";\n\nexport default class DraggableLinesDragMarker extends DraggableLinesMarker {\n\n    _idx: number | [number, number];\n    _removeOnClick: boolean;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, idx: number | [number, number], options: MarkerOptions, removeOnClick: boolean) {\n        super(draggable, layer, latlng, false, {\n            draggable: true,\n            ...options\n        });\n\n        this._idx = idx;\n        this._removeOnClick = removeOnClick;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        const latlngs = this._layer.getDraggableLinesRoutePoints() || (this._layer.getLatLngs() as LatLng[] | LatLng[][]);\n        const points = Array.isArray(this._idx) ? (latlngs as LatLng[][])[this._idx[0]] : (latlngs as LatLng[]);\n\n        if (this._removeOnClick && points.length > (this._layer instanceof Polygon ? 3 : 2)) {\n            this.on('click', this.handleClick);\n        }\n\n        this.on(\"mouseover\", () => {\n            this._draggable.fire(\"dragmouseover\", { layer: this._layer, idx: this._idx, marker: this });\n        });\n        this.on(\"mouseout\", () => {\n            this._draggable.fire(\"dragmouseout\", { layer: this._layer, idx: this._idx, marker: this });\n        });\n\n        return this;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    handleClick() {\n        const idx = this.getIdx();\n\n        removePoint(this._layer, idx);\n        // Markers are redrawn automatically because we update the line points\n\n        this._draggable.fire('remove', { layer: this._layer, idx });\n    }\n\n}\n","import { Icon } from 'leaflet';\nimport defaultIconDataUrl from './assets/marker.svg';\nimport plusIconDataUrl from './assets/plus.svg';\nimport markerShadowUrl from './assets/marker-shadow.png';\n\nfunction createIcon(colors: Record<string, string>) {\n    let url = defaultIconDataUrl;\n    for (const key of Object.keys(colors)) {\n        url = url.replace(new RegExp(`%24%7b${key}%7d`, 'g'), encodeURIComponent(colors[key]))\n    }\n    return new Icon.Default({ imagePath: new String('') as string, iconUrl: url, iconRetinaUrl: url, shadowUrl: markerShadowUrl }) as Icon;\n}\n\nexport const defaultIcon = createIcon({ color1: \"#2e6c97\", color2: \"#3883b7\", color3: \"#126fc6\", color4: \"#4c9cd1\" });\nexport const startIcon = createIcon({ color1: \"#2E9749\", color2: \"#06EA3F\", color3: \"#03D337\", color4: \"#40DD68\" });\nexport const endIcon = createIcon({ color1: \"#972E2E\", color2: \"#B73838\", color3: \"#C61212\", color4: \"#D14C4C\" });\n\nexport const plusIcon = new Icon({\n    iconUrl: plusIconDataUrl,\n    iconSize: [24, 24],\n    iconAnchor: [12, 12]\n});","import { LatLng, LatLngExpression, LeafletEvent, Map, Marker, MarkerOptions, Polyline } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { setPoint } from \"../utils\";\n\nexport default abstract class DraggableLinesMarker extends Marker {\n\n    _draggable: DraggableLinesHandler;\n    _layer: Polyline;\n    _isInsert: boolean;\n\n    _dragIdx?: number | [number, number];\n    _dragFrom?: LatLng;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, isInsert: boolean, options?: MarkerOptions) {\n        super(latlng, options);\n\n        this._draggable = draggable;\n        this._layer = layer;\n        this._isInsert = isInsert;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        this.on(\"dragstart\", this.handleDragStart, this);\n        this.on(\"drag\", this.handleDrag, this);\n        this.on(\"dragend\", this.handleDragEnd, this);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        super.onRemove(map);\n\n        return this;\n    }\n\n    abstract getIdx(): number | [number, number];\n\n    handleDragStart(e: LeafletEvent) {\n        const latlng = this.getLatLng();\n        this._dragFrom = latlng;\n        this._dragIdx = this.getIdx();\n\n        setPoint(this._layer, latlng, this._dragIdx, this._isInsert);\n\n        this._draggable.fire('dragstart', { layer: this._layer, from: latlng, to: latlng, idx: this._dragIdx, isNew: this._isInsert });\n    };\n\n    handleDrag() {\n        const latlng = this.getLatLng();\n\n        setPoint(this._layer, latlng, this._dragIdx!, false);\n\n        this._draggable.fire('drag', { layer: this._layer, from: this._dragFrom!, to: latlng, idx: this._dragIdx!, isNew: this._isInsert });\n    }\n\n    handleDragEnd() {\n        const event = { layer: this._layer, from: this._dragFrom!, to: this.getLatLng(), idx: this._dragIdx!, isNew: this._isInsert };\n\n        Promise.resolve().then(() => {\n            // Set points on the next tick so that Dragging._draggable is unset and DraggableLinesHandler reacts to the route point update\n            // and rerenders the markers.\n            setPoint(event.layer, event.to, event.idx, false);\n            this._draggable.fire('dragend', event);\n        });\n    };\n\n}\n","import { DomUtil, LatLng, LatLngExpression, LeafletMouseEvent, Map, MarkerOptions, Polyline } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport DraggableLinesMarker from \"./marker\";\nimport DraggableLinesTempMarker from \"./tempMarker\";\n\nexport default class DraggableLinesPlusMarker extends DraggableLinesMarker {\n\n    _idx: number | [number, number];\n    _tempMarker?: DraggableLinesPlusTempMarker;\n    _tempMarkerOptions: MarkerOptions;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, idx: number | [number, number], options: MarkerOptions, tempMarkerOptions: MarkerOptions) {\n        super(draggable, layer, latlng, true, {\n            pane: \"overlayPane\",\n            zIndexOffset: -200000,\n            ...options\n        });\n\n        this._idx = idx;\n        this._tempMarkerOptions = tempMarkerOptions;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        this.on('mouseover', this.handleMouseOver, this);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        super.onRemove(map);\n\n        if (this._tempMarker) {\n            this._tempMarker.remove();\n            delete this._tempMarker;\n        }\n        \n        return this;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    handleMouseOver(e: LeafletMouseEvent) {\n        this._draggable.removeTempMarker();\n\n        this._tempMarker = new DraggableLinesPlusTempMarker(this._draggable, this._layer, this, e.latlng, this.getIdx(), this._tempMarkerOptions).addTo(this._map)\n        this._draggable._tempMarker = this._tempMarker;\n    }\n\n}\n\nexport class DraggableLinesPlusTempMarker extends DraggableLinesTempMarker {\n    \n    _plusMarker: DraggableLinesPlusMarker;\n    _idx: number | [number, number];\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, plusMarker: DraggableLinesPlusMarker, latlng: LatLngExpression, idx: number | [number, number], options: MarkerOptions) {\n        super(draggable, layer, latlng, options);\n\n        this._plusMarker = plusMarker;\n        this._idx = idx;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    shouldRemove(latlng: LatLng) {\n        const layerPoint = this._map.latLngToLayerPoint(latlng);\n        const position = DomUtil.getPosition(this._plusMarker._icon);\n        return Math.abs(position.y - layerPoint.y) > this._plusMarker._icon.offsetHeight / 2\n            || Math.abs(position.x - layerPoint.x) > this._plusMarker._icon.offsetWidth / 2;\n    }\n\n    getRenderPoint() {\n        return this.getLatLng();\n    }\n\n    fireMouseOver() {\n        this._draggable.fire(\"plusmouseover\", { layer: this._layer, idx: this.getIdx(), marker: this, plusMarker: this._plusMarker });\n    }\n\n\n    fireMouseMove() {\n    }\n\n    fireMouseOut() {\n        this._draggable.fire(\"plusmouseout\", { layer: this._layer, idx: this.getIdx(), marker: this, plusMarker: this._plusMarker });\n    }\n\n}","import { DivIcon, DomEvent, Draggable, GeometryUtil, Icon, latLng, LatLng, LatLngExpression, LeafletMouseEvent, Map, MarkerOptions, Polygon, Polyline, Util } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { getInsertPosition, getRouteInsertPosition, setPoint } from \"../utils\";\nimport DraggableLinesMarker from \"./marker\";\n\nfunction createIcon(layer: Polyline, baseIcon: Icon | DivIcon) {\n    const icon = Util.create(baseIcon);\n    const _setIconStyles = icon._setIconStyles;\n    icon._setIconStyles = (img: HTMLImageElement, name: string) => {\n        _setIconStyles.call(icon, img, name);\n\n        // Create a padding around the marker to make sure that we don't accidentally trigger an unwanted mouseout\n        // event while hovering around on the line.\n        const padding = layer.options.weight! * 2;\n        img.style.padding = `${padding}px`;\n        img.style.boxSizing = \"content-box\";\n        img.style.marginLeft = `${parseInt(img.style.marginLeft) - padding}px`;\n        img.style.marginTop = `${parseInt(img.style.marginTop) - padding}px`;\n    };\n    return icon;\n}\n\nexport default class DraggableLinesTempMarker extends DraggableLinesMarker {\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, options: MarkerOptions) {\n        super(draggable, layer, latlng, true, {\n            draggable: true,\n            zIndexOffset: -100000,\n            ...options,\n            icon: createIcon(layer, options.icon!)\n        });\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        map.on(\"mousemove\", this.handleMapMouseMove, this);\n        DomEvent.on(map.getContainer(), \"mouseover\", this.handleMapMouseOver, this); // Bind manually since map.on(\"mouseover\") does not receive bubbling events\n        this.on('click', this.handleClick, this);\n\n        this.fireMouseOver();\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        if (!this.isHidden())\n            this.fireMouseOut();\n\n        super.onRemove(map);\n\n        map.off(\"mousemove\", this.handleMapMouseMove, this);\n        DomEvent.off(map.getContainer(), \"mouseover\", this.handleMapMouseOver, this);\n\n        return this;\n    }\n\n    show() {\n        this._icon.style.display = '';\n        if (this._shadow)\n            this._shadow.style.display = '';\n\n        this.fireMouseOver();\n    }\n\n    hide() {\n        this._icon.style.display = 'none';\n        if (this._shadow)\n            this._shadow.style.display = 'none';\n\n        this.fireMouseOut();\n    }\n\n    isHidden() {\n        return this._icon.style.display == 'none';\n    }\n\n    getIdx() {\n        const latlng = this.getLatLng();\n        if (this._layer.hasDraggableLinesRoutePoints())\n            return getRouteInsertPosition(this._map, this._layer.getDraggableLinesRoutePoints()!, this._layer.getLatLngs() as any, latlng);\n        else\n            return getInsertPosition(this._map, this._layer.getLatLngs() as LatLng[] | LatLng[][], latlng, this._layer instanceof Polygon);\n    }\n\n\n    handleClick() {\n        const latlng = this.getLatLng();\n        const idx = this.getIdx();\n\n        setPoint(this._layer, latlng, idx, true);\n\n        this._draggable.fire('insert', { layer: this._layer, latlng, idx });\n    }\n\n\n    shouldRemove(latlng: LatLng) {\n        return !this._layer._containsPoint(this._map.latLngToLayerPoint(latlng));\n    }\n\n\n    getRenderPoint(latlng: LatLng): LatLng | undefined {\n        const closest = GeometryUtil.closest(this._map, this._layer, latlng)!;\n\n        // In case of a polygon, we want to hide the marker while we are hovering the fill, we only want to show\n        // it while we are hovering the outline.\n        if (closest.distance > this._layer.options.weight! / 2 + 1)\n            return undefined;\n        \n        return latLng(closest);\n    }\n\n\n    handleMapMouseMove(e: LeafletMouseEvent) {\n        if (Draggable._dragging)\n            return;\n\n        if (this.shouldRemove(this._map.mouseEventToLatLng(e.originalEvent))) {\n            this.remove();\n            return;\n        }\n\n        const latlng = this.getRenderPoint(this._map.mouseEventToLatLng(e.originalEvent));\n\n        if (latlng)\n            this.setLatLng(latlng);\n\n        const isVisible = !this.isHidden();\n        if (latlng && !isVisible)\n            this.show();\n        else if (!latlng && isVisible)\n            this.hide();\n        else if (isVisible)\n            this.fireMouseMove();\n    };\n\n\n    handleMapMouseOver(e: Event) {\n        if (!Draggable._dragging && e.target !== this.getElement() && e.target !== this._layer.getElement())\n            this.remove();\n    };\n\n\n    fireMouseOver() {\n        this._draggable.fire(\"tempmouseover\", { layer: this._layer, idx: this.getIdx(), marker: this, latlng: this.getLatLng() });\n    }\n\n\n    fireMouseMove() {\n        this._draggable.fire(\"tempmousemove\", { layer: this._layer, idx: this.getIdx(), marker: this, latlng: this.getLatLng() });\n    }\n\n    fireMouseOut() {\n        this._draggable.fire(\"tempmouseout\", { layer: this._layer, idx: this.getIdx(), marker: this, latlng: this.getLatLng() });\n    }\n\n}","import L, { LatLng, LineUtil, Map, Polyline } from \"leaflet\";\nimport GeometryUtil from \"leaflet-geometryutil\";\n\nexport type PolylineIndex = number | [number, number];\n\n/**\n * If `points` is the array of coordinates or array of arrays of coordinates that a Polyline/Polygon consists of and `point` is the\n * coordinates where the dragging starts, this method returns the index in the `points` array where the new point should be inserted.\n * The returned value is a number of a tuple of two numbers, depending on whether `points` is an array or an array of arrays.\n *\n * @param map: The instance of `L.Map`.\n * @param points: An array of coordinates or array of arrays of coordinates as returned by `layer.getLatLngs()`.\n * @param point: An instance of `L.LatLng` that represents the point on the line where dragging has started.\n * @param allowExtendingLine: If `true` (default), will return `0` or `points.length` if the dragging has started before the beginning\n * or after the end of the line. If `false`, will always return at least `1` and at most `points.length - 1` to prevent the\n * beginning/end of the line to be modified. Has no effect if `isPolygon` is `true`.\n * @param isPolygon: If `true`, `points` will be considered to be the coordinates of a polygon, if `false` (default), it will be considered\n * the coordinates of a line. The difference between a polygon and a line is that in a polygon, the first point and the last point\n * of the coordinates listed in `points` are connected by an additional segment that can also be dragged.\n */\nexport function getInsertPosition(map: Map, points: LatLng[], point: LatLng, isPolygon?: boolean): number;\nexport function getInsertPosition(map: Map, points: LatLng[][], point: LatLng, isPolygon?: boolean): [number, number];\nexport function getInsertPosition(map: Map, points: LatLng[] | LatLng[][], point: LatLng, isPolygon?: boolean): number | [number, number];\nexport function getInsertPosition(map: Map, points: LatLng[] | LatLng[][], point: LatLng, isPolygon = false): number | [number, number] {\n    if (!LineUtil.isFlat(points)) {\n        // In case of a multi polyline/polygon, we need to figure out first which one of the polylines/polygons the closest point is on.\n        // GeometryUtil.closest() doesn't seem to tell us that, so we need to check the distance to each sub polyline/polygon manually.\n        // Internally, GeometryUtil.closest() seems to do it the same way.\n        let result: { distance: number, i: number } | undefined;\n        for (let i = 0; i < points.length; i++) {\n            const polyline = isPolygon ? L.polygon(points[i]) : L.polyline(points[i]);\n            const distance = GeometryUtil.closest(map, polyline, point)!.distance;\n            if (!result || distance < result.distance) {\n                result = { distance, i };\n            }\n        }\n        return result ? [result.i, getInsertPosition(map, points[result.i], point, isPolygon)] : [0, 0];\n    }\n\n    const polyline = L.polyline(isPolygon ? [...points, points[0]] : points);\n    const pos = GeometryUtil.locateOnLine(map, polyline, point);\n    const before = L.GeometryUtil.extract(map, polyline, 0, pos);\n    \n    let idx = before.length - 1;\n    if (!isPolygon)\n        idx = Math.max(1, Math.min(points.length - 1, idx));\n    return idx;\n}\n\n\n/**\n * Similar to `getInsertPosition`, but for a line where the points returned by `getLatLngs()` (“track points”) are a route that has been\n * calculated to be the best connection between a set of waypoints (“route points”). Dragging starts on a segment between two track\n * points, but should lead an additional point in the set of route points rather than track points, so that the route can be recalculated.\n * This method returns the index where the new route point should be inserted into the array of route points.\n * @param map: The instance of `L.Map`.\n * @param routePoints: An array of coordinates that are the waypoints that are used as the basis for calculating the route.\n * @param trackPoints: An array of coordinates as returned by `layer.getLatLngs()`.\n * @param point: An instance of `L.LatLng` that represents the point on the line where dragging has started.\n */\nexport function getRouteInsertPosition(map: Map, routePoints: LatLng[], trackPoints: LatLng[], point: LatLng): number {\n    const polyline = L.polyline(trackPoints);\n    const pos = GeometryUtil.locateOnLine(map, polyline, point);\n\n    for (let i = 0; i < routePoints.length; i++) {\n        if (GeometryUtil.locateOnLine(map, polyline, routePoints[i]) > pos)\n            return i;\n    }\n    return routePoints.length;\n}\n\nexport function getFromPosition<T, A extends T[] | T[][]>(arr: A, idx: PolylineIndex): T {\n    return Array.isArray(idx) ? (arr as any)[idx[0]][idx[1]] : arr[idx];\n}\n\n/**\n * Returns a copy of the `arr` array with `item` inserted at the index `idx`. `arr` can be an array or an array of arrays (as\n * returned by `getLatLngs()` on a Polyline/Polygon), and `idx` can be a number or a tuple of two numbers as returned by\n * `L.DraggableLines.getInsertPosition()` (and as passed along with the drag events). This method can be used to easily insert\n * a new point at the right position.\n */\nexport function insertAtPosition<T, A extends T[] | T[][]>(arr: A, item: T, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), item, ...arr.slice(idxArr[0])] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = insertAtPosition(result[idxArr[0]] as any, item, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\n/**\n * Like `L.DraggableLines.insertAtPosition`, but overwrites the item at the given index instead of inserting it there.\n * \n * Returns a copy of the `arr` array with the item at index `idx` overwritten with `item`. `arr` can be an array or an array\n * of arrays (as returned by `getLatLngs()` on a Polyline/Polygon), and `idx` can be a number or a tuple of two numbers as\n * returned by `L.DraggableLines.getInsertPosition()` (and as passed along with the drag events). This method can be used\n * to easily update a new point at the right position while the user is dragging:\n */\nexport function updateAtPosition<T, A extends T[] | T[][]>(arr: A, item: T, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), item, ...arr.slice(idxArr[0] + 1)] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = updateAtPosition(result[idxArr[0]] as any, item, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\nexport function removeFromPosition<A extends any[] | any[][]>(arr: A, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), ...arr.slice(idxArr[0] + 1)] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = removeFromPosition(result[idxArr[0]] as any, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\nexport function setPoint(layer: Polyline, point: LatLng, idx: number | [number, number], insert: boolean) {\n    const hasRoutePoints = layer.hasDraggableLinesRoutePoints();\n    \n    let points = hasRoutePoints ? layer.getDraggableLinesRoutePoints()! : layer.getLatLngs() as LatLng[] | LatLng[][];\n    \n    if (insert)\n        points = insertAtPosition(points, point, idx);\n    else\n        points = updateAtPosition(points, point, idx);\n    \n    if (hasRoutePoints)\n        layer.setDraggableLinesRoutePoints(points as any);\n    else\n        layer.setLatLngs(points);\n}\n\nexport function removePoint(layer: Polyline, idx: number | [number, number]) {\n    const hasRoutePoints = layer.hasDraggableLinesRoutePoints();\n    \n    let points = hasRoutePoints ? layer.getDraggableLinesRoutePoints()! : layer.getLatLngs() as LatLng[] | LatLng[][];\n    points = removeFromPosition(points, idx);\n\n    if (hasRoutePoints)\n        layer.setDraggableLinesRoutePoints(points as any);\n    else\n        layer.setLatLngs(points);\n}\n\nexport function getPlusIconPoint(map: Map, trackPoints: LatLng[], distance: number, atStart: boolean) {\n    const tr = atStart ? trackPoints : [...trackPoints].reverse();\n\n    const point0 = map.latLngToContainerPoint(tr[0]);\n    const tr1 = tr.find((p, i) => i > 0 && point0.distanceTo(map.latLngToContainerPoint(p)) > 0);\n\n    let result;\n    if (!tr1) {\n        result = L.point(point0.x + (atStart ? -1 : 1) * distance, point0.y);\n    } else {\n        const point1 = map.latLngToContainerPoint(tr1);\n\n        const fraction = distance / point0.distanceTo(point1);\n\n        result = L.point(point0.x - fraction * (point1.x - point0.x), point0.y - fraction * (point1.y - point0.y));\n    }\n\n    return map.containerPointToLatLng(result);\n}","module.exports = __WEBPACK_EXTERNAL_MODULE__453__;","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"sourceRoot":""}