{"version":3,"sources":["webpack://L.DraggableLines/webpack/universalModuleDefinition","webpack://L.DraggableLines/./src/handler.ts","webpack://L.DraggableLines/./src/index.ts","webpack://L.DraggableLines/./src/injections.ts","webpack://L.DraggableLines/./src/markers/dragMarker.ts","webpack://L.DraggableLines/./src/markers/icons.ts","webpack://L.DraggableLines/./src/markers/marker.ts","webpack://L.DraggableLines/./src/markers/plusMarker.ts","webpack://L.DraggableLines/./src/markers/tempMarker.ts","webpack://L.DraggableLines/./src/utils.ts","webpack://L.DraggableLines/./src/markers/marker.svg","webpack://L.DraggableLines/./src/markers/plus.svg","webpack://L.DraggableLines/external {\"commonjs\":\"leaflet\",\"commonjs2\":\"leaflet\",\"amd\":\"leaflet\",\"root\":\"L\"}","webpack://L.DraggableLines/external {\"commonjs\":\"leaflet-geometryutil\",\"commonjs2\":\"leaflet-geometryutil\",\"amd\":\"leaflet-geometryutil\",\"root\":[\"L\",\"GeometryUtil\"]}","webpack://L.DraggableLines/webpack/bootstrap","webpack://L.DraggableLines/webpack/startup","webpack://L.DraggableLines/webpack/runtime/define property getters","webpack://L.DraggableLines/webpack/runtime/hasOwnProperty shorthand","webpack://L.DraggableLines/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__453__","__WEBPACK_EXTERNAL_MODULE__7__","map","options","handleLayerAdd","e","layer","Polyline","enableForLayer","handleLayerRemove","disableForLayer","handleLayerMouseOver","Draggable","_dragging","drawTempMarker","target","latlng","handleLayerSetLatLngs","removeTempMarker","_draggableLines","drawDragMarkers","drawPlusMarkers","interactive","allowExtendingLine","removeOnClick","addHooks","this","_map","on","eachLayer","removeHooks","removeDragMarkers","latlngs","getDraggableLinesRoutePoints","getLatLngs","routePoints","LineUtil","isFlat","i","length","j","idx","icon","Polygon","defaultIcon","startIcon","endIcon","dragMarkerOptions","marker","addTo","dragMarkers","push","fire","removeFrom","removePlusMarkers","trackPoints","isStart","plusIcon","plusMarkerOptions","tempMarkerOptions","plusTempMarkerOptions","getPlusIconPoint","weight","plusMarkers","_tempMarker","closest","zoomEndHandler","redrawForLayer","_layer","getLatLng","off","redraw","enable","Handler","Object","assign","DraggableLinesHandler","prototype","Evented","DraggableLinesMarker","DraggableLinesDragMarker","DraggableLinesTempMarker","DraggableLinesPlusMarker","DraggableLines","utils","icons","Marker","DragMarker","TempMarker","PlusMarker","hasDraggableLinesRoutePoints","draggableLinesRoutePoints","p","latLng","setDraggableLinesRoutePoints","setLatLngsBkp","setLatLngs","result","apply","args","draggable","_idx","_removeOnClick","onAdd","points","Array","isArray","handleClick","getIdx","removePoint","_draggable","imagePath","Icon","Default","_detectIconPath","createIcon","colors","url","default","keys","key","replace","RegExp","encodeURIComponent","String","iconUrl","iconRetinaUrl","shadowUrl","color1","color2","color3","color4","iconSize","iconAnchor","isInsert","_isInsert","handleDragStart","handleDrag","handleDragEnd","onRemove","_dragFrom","_dragIdx","setPoint","from","to","isNew","event","Promise","resolve","then","pane","zIndexOffset","_tempMarkerOptions","handleMouseOver","remove","DraggableLinesPlusTempMarker","plusMarker","_plusMarker","shouldRemove","layerPoint","latLngToLayerPoint","position","DomUtil","getPosition","_icon","Math","abs","y","offsetHeight","x","offsetWidth","getRenderPoint","baseIcon","Util","create","_setIconStyles","img","name","call","padding","style","marginLeft","parseInt","marginTop","handleMapMouseMove","DomEvent","getContainer","handleMapMouseOver","show","display","_shadow","hide","isHidden","getRouteInsertPosition","getInsertPosition","_containsPoint","GeometryUtil","distance","mouseEventToLatLng","originalEvent","setLatLng","isVisible","getElement","insertAtPosition","arr","item","idxArr","slice","updateAtPosition","removeFromPosition","point","isPolygon","polygon","polyline","pos","locateOnLine","extract","max","min","insert","hasRoutePoints","atStart","tr","reverse","point0","latLngToContainerPoint","tr1","find","distanceTo","point1","fraction","console","log","containerPointToLatLng","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","o","defineProperty","enumerable","get","obj","prop","hasOwnProperty","r","Symbol","toStringTag","value"],"mappings":"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","file":"L.DraggableLines.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"leaflet\"), require(\"leaflet-geometryutil\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"leaflet\", \"leaflet-geometryutil\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"L.DraggableLines\"] = factory(require(\"leaflet\"), require(\"leaflet-geometryutil\"));\n\telse\n\t\troot[\"L.DraggableLines\"] = factory(root[\"L\"], root[\"L\"][\"GeometryUtil\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__453__, __WEBPACK_EXTERNAL_MODULE__7__) {\nreturn ","import L, { Draggable, Evented, Handler, Icon, LatLng, Layer, LeafletEvent, LeafletMouseEvent, LineUtil, Map, Marker, MarkerOptions, Polygon, Polyline } from 'leaflet';\nimport GeometryUtil from 'leaflet-geometryutil';\nimport { defaultIcon, endIcon, plusIcon, startIcon } from './markers/icons';\nimport DraggableLinesDragMarker from './markers/dragMarker';\nimport DraggableLinesPlusMarker from './markers/plusMarker';\nimport DraggableLinesTempMarker from './markers/tempMarker';\nimport { getPlusIconPoint } from './utils';\n\nexport interface DraggableLinesHandlerOptions {\n    enableForLayer?: boolean | ((layer: Polyline) => boolean);\n    dragMarkerOptions?: (layer: Polyline, i: number, length: number) => MarkerOptions;\n    tempMarkerOptions?: (layer: Polyline) => MarkerOptions;\n    plusMarkerOptions?: (layer: Polyline, isStart: boolean) => MarkerOptions;\n    plusTempMarkerOptions?: (layer: Polyline, isStart: boolean) => MarkerOptions;\n    allowExtendingLine?: boolean;\n    removeOnClick?: boolean;\n}\n\nexport default class DraggableLinesHandler extends Handler {\n\n    options: DraggableLinesHandlerOptions;\n    \n    _tempMarker?: DraggableLinesTempMarker;\n\n    constructor(map: Map, options?: DraggableLinesHandlerOptions) {\n        super(map);\n\n        this.options = {\n            enableForLayer: (layer) => layer.options.interactive!,\n            allowExtendingLine: true,\n            removeOnClick: true,\n            ...options\n        };\n    }\n\n    addHooks() {\n        this._map.on(\"layeradd\", this.handleLayerAdd);\n        this._map.on(\"layerremove\", this.handleLayerRemove);\n\n        this._map.eachLayer((layer) => { this.handleLayerAdd({ layer }); });\n    }\n\n    removeHooks() {\n        this._map.on(\"layeradd\", this.handleLayerAdd);\n        this._map.on(\"layerremove\", this.handleLayerRemove);\n\n        this._map.eachLayer((layer) => { this.handleLayerRemove({ layer }); });\n    }\n\n    handleLayerAdd = (e: { layer: Layer }) => {\n        if (e.layer instanceof Polyline && (typeof this.options.enableForLayer === \"function\" ? this.options.enableForLayer!(e.layer) : this.options.enableForLayer))\n            this.enableForLayer(e.layer as Polyline);\n    };\n\n    handleLayerRemove = (e: { layer: Layer }) => {\n        if (e.layer instanceof Polyline)\n            this.disableForLayer(e.layer as Polyline);\n    };\n\n    handleLayerMouseOver = (e: LeafletMouseEvent) => {\n        if (Draggable._dragging)\n            return;\n\n        this.drawTempMarker(e.target as Polyline, e.latlng);\n    };\n\n    handleLayerSetLatLngs = (e: LeafletEvent) => {\n        const layer = e.target as Polyline;\n        if (!Draggable._dragging) {\n            this.removeTempMarker();\n\n            if (layer._draggableLines) {\n                this.drawDragMarkers(layer);\n                this.drawPlusMarkers(layer);\n            }\n        }\n    };\n\n    drawDragMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n\n        this.removeDragMarkers(layer);\n        \n        const latlngs = layer.getDraggableLinesRoutePoints() || (layer.getLatLngs() as LatLng[] | LatLng[][]);\n        const routePoints = LineUtil.isFlat(latlngs) ? [latlngs] : latlngs;\n        const isFlat = LineUtil.isFlat(latlngs);\n        for (let i = 0; i < routePoints.length; i++) {\n            for (let j = 0; j < routePoints[i].length; j++) {\n                const idx = isFlat ? j : [i, j] as [number, number];\n\n                let removeOnClick = this.options.removeOnClick!;\n                const options = {\n                    icon: layer instanceof Polygon ? defaultIcon : (j == 0 ? startIcon : j == routePoints[i].length - 1 ? endIcon : defaultIcon),\n                    ...this.options.dragMarkerOptions?.(layer, j, routePoints[i].length)\n                };\n                const marker = new DraggableLinesDragMarker(this, layer, routePoints[i][j], idx, options, removeOnClick).addTo(this._map);\n                layer._draggableLines.dragMarkers.push(marker);\n\n                marker.on(\"mouseover\", () => {\n                    this.fire(\"dragmouseover\", { layer, idx, marker });\n                });\n                marker.on(\"mouseout\", () => {\n                    this.fire(\"dragmouseout\", { layer, idx, marker });\n                });\n            }\n        }\n    }\n\n    removeDragMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n        \n        for (const marker of layer._draggableLines.dragMarkers) {\n            marker.removeFrom(this._map);\n        }\n        layer._draggableLines.dragMarkers = [];\n    }\n\n    drawPlusMarkers(layer: Polyline) {\n        this.removePlusMarkers(layer);\n\n        if (layer instanceof Polygon || !layer._draggableLines || !this.options.allowExtendingLine)\n            return;\n\n        const latlngs = layer.getLatLngs() as LatLng[] | LatLng[][];\n        const trackPoints = LineUtil.isFlat(latlngs) ? [latlngs] : latlngs;\n        const routePoints = layer.getDraggableLinesRoutePoints();\n        \n        for (let i = 0; i < trackPoints.length; i++) {\n            if (trackPoints[i].length < 2)\n                continue;\n\n            for (const isStart of [true, false]) {\n                let idx: number | [number, number];\n                if (routePoints)\n                    idx = isStart ? 0 : routePoints.length;\n                else if (LineUtil.isFlat(latlngs))\n                    idx = isStart ? 0 : trackPoints[i].length;\n                else\n                    idx = isStart ? [i, 0] : [i, trackPoints[i].length];\n                \n                const options = {\n                    icon: plusIcon,\n                    ...this.options.plusMarkerOptions?.(layer, isStart)\n                };\n                const tempMarkerOptions = {\n                    icon: isStart ? startIcon : endIcon,\n                    ...this.options.plusTempMarkerOptions?.(layer, isStart)\n                };\n                const marker = new DraggableLinesPlusMarker(this, layer, getPlusIconPoint(this._map, trackPoints[i], 24 + layer.options.weight! / 2, isStart), idx, options, tempMarkerOptions).addTo(this._map);\n                layer._draggableLines.plusMarkers.push(marker);\n            }\n        }\n    }\n\n    removePlusMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n        \n        for (const marker of layer._draggableLines.plusMarkers) {\n            marker.removeFrom(this._map);\n        }\n        layer._draggableLines.plusMarkers = [];\n    }\n\n    drawTempMarker(layer: Polyline, latlng: LatLng) {\n        this.removeTempMarker();\n\n        const options = {\n            icon: defaultIcon,\n            ...this.options.tempMarkerOptions?.(layer)\n        };\n        this._tempMarker = new DraggableLinesTempMarker(this, layer, GeometryUtil.closest(this._map, layer, latlng)!, options).addTo(this._map);\n    }\n\n    removeTempMarker() {\n        if (this._tempMarker) {\n            this._tempMarker.removeFrom(this._map);\n            delete this._tempMarker;\n        }\n    }\n\n    enableForLayer(layer: Polyline) {\n        if (layer._draggableLines)\n            return;\n\n        layer._draggableLines = {\n            dragMarkers: [],\n            plusMarkers: [],\n            zoomEndHandler: () => {\n                this.drawPlusMarkers(layer);\n            }\n        };\n        layer.on(\"mouseover\", this.handleLayerMouseOver);\n        layer.on(\"draggableLines-setLatLngs\", this.handleLayerSetLatLngs);\n        layer.on(\"draggableLines-setRoutePoints\", this.handleLayerSetLatLngs);\n        this._map.on(\"zoomend\", layer._draggableLines.zoomEndHandler);\n        this.drawDragMarkers(layer);\n        this.drawPlusMarkers(layer);\n    }\n\n    redrawForLayer(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n\n        this.drawDragMarkers(layer);\n        this.drawPlusMarkers(layer);\n\n        if (this._tempMarker && this._tempMarker._layer === layer)\n            this.drawTempMarker(layer, this._tempMarker.getLatLng());\n    }\n\n    disableForLayer(layer: Polyline) {\n        layer.off(\"mouseover\", this.handleLayerMouseOver);\n        layer.off(\"draggableLines-setLatLngs\", this.handleLayerSetLatLngs);\n        layer.off(\"draggableLines-setRoutePoints\", this.handleLayerSetLatLngs);\n        if (layer._draggableLines)\n            this._map.off(\"zoomend\", layer._draggableLines.zoomEndHandler);\n        this.removeDragMarkers(layer);\n        this.removePlusMarkers(layer);\n        delete layer._draggableLines;\n    }\n\n    redraw() {\n        this._map.eachLayer((layer) => {\n            if (!(layer instanceof Polyline))\n                return;\n\n            const enable = typeof this.options.enableForLayer === \"function\" ? this.options.enableForLayer(layer) : this.options.enableForLayer;\n            if (layer._draggableLines && !enable)\n                this.disableForLayer(layer);\n            else if (!layer._draggableLines && enable)\n                this.enableForLayer(layer);\n            else if (layer._draggableLines)\n                this.redrawForLayer(layer);\n        });\n    }\n\n}\n\nexport default interface DraggableLinesHandler extends Evented {}\nObject.assign(DraggableLinesHandler.prototype, Evented.prototype);\n","import L from 'leaflet';\nimport DraggableLinesHandler from './handler';\nimport './injections';\nimport * as utils from './utils';\nimport * as icons from './markers/icons';\nimport DraggableLinesMarker from './markers/marker';\nimport DraggableLinesDragMarker from './markers/dragMarker';\nimport DraggableLinesTempMarker from './markers/tempMarker';\nimport DraggableLinesPlusMarker from './markers/plusMarker';\n\nexport * from './utils';\nexport * from './markers/icons';\nexport { DraggableLinesMarker, DraggableLinesDragMarker, DraggableLinesTempMarker, DraggableLinesPlusMarker };\n\ntype DraggableLinesType = typeof DraggableLinesHandler;\n\ndeclare module \"leaflet\" {\n    let DraggableLines: DraggableLinesType\n        & typeof utils\n        & {\n            icons: typeof icons;\n            Marker: typeof DraggableLinesMarker;\n            DragMarker: typeof DraggableLinesDragMarker;\n            TempMarker: typeof DraggableLinesTempMarker;\n            PlusMarker: typeof DraggableLinesPlusMarker;\n        };\n}\n\nL.DraggableLines = Object.assign(DraggableLinesHandler, {\n    ...utils,\n    icons,\n    Marker: DraggableLinesMarker,\n    DragMarker: DraggableLinesDragMarker,\n    TempMarker: DraggableLinesTempMarker,\n    PlusMarker: DraggableLinesPlusMarker\n});\n\nexport default DraggableLinesHandler;","import { latLng, LatLngExpression, Marker, Polyline } from \"leaflet\";\n\nPolyline.prototype.hasDraggableLinesRoutePoints = function() {\n    return this.options.draggableLinesRoutePoints != null;\n};\n\nPolyline.prototype.getDraggableLinesRoutePoints = function() {\n    return this.options.draggableLinesRoutePoints?.map((p) => latLng(p));\n};\n\nPolyline.prototype.setDraggableLinesRoutePoints = function(routePoints: LatLngExpression[] | undefined) {\n    this.options.draggableLinesRoutePoints = routePoints;\n    this.fire('draggableLines-setRoutePoints');\n};\n\nconst setLatLngsBkp = Polyline.prototype.setLatLngs;\nPolyline.prototype.setLatLngs = function(...args: any) {\n    const result = setLatLngsBkp.apply(this, args);\n    this.fire('draggableLines-setLatLngs');\n    return result;\n};\n\ninterface PolylineInfo {\n    dragMarkers: Marker[];\n    plusMarkers: Marker[];\n    zoomEndHandler: () => void;\n}\n\ndeclare module \"leaflet\" {\n    interface Polyline {\n        hasDraggableLinesRoutePoints: () => boolean;\n        getDraggableLinesRoutePoints: () => LatLng[] | undefined;\n        setDraggableLinesRoutePoints: (routePoints: LatLngExpression[] | undefined) => void;\n    }\n\n    interface PolylineOptions {\n        draggableLinesRoutePoints?: LatLngExpression[];\n    }\n\n    interface Polyline {\n        _draggableLines?: PolylineInfo;\n    }\n}","import { Icon, LatLng, LatLngExpression, Map, MarkerOptions, Polygon, Polyline } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { removePoint } from \"../utils\";\nimport DraggableLinesMarker from \"./marker\";\n\nexport default class DraggableLinesDragMarker extends DraggableLinesMarker {\n\n    _idx: number | [number, number];\n    _removeOnClick: boolean;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, idx: number | [number, number], options: MarkerOptions, removeOnClick: boolean) {\n        super(draggable, layer, latlng, false, {\n            draggable: true,\n            ...options\n        });\n\n        this._idx = idx;\n        this._removeOnClick = removeOnClick;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        const latlngs = this._layer.getDraggableLinesRoutePoints() || (this._layer.getLatLngs() as LatLng[] | LatLng[][]);\n        const points = Array.isArray(this._idx) ? (latlngs as LatLng[][])[this._idx[0]] : (latlngs as LatLng[]);\n\n        if (this._removeOnClick && points.length > (this._layer instanceof Polygon ? 3 : 2)) {\n            this.on('click', this.handleClick);\n        }\n\n        return this;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    handleClick() {\n        const idx = this.getIdx();\n\n        removePoint(this._layer, idx);\n        // Markers are redrawn automatically because we update the line points\n\n        this._draggable.fire('remove', { layer: this._layer, idx });\n    }\n\n}\n","import { Icon } from 'leaflet';\nimport defaultIconDataUrl from './marker.svg';\nimport plusIconDataUrl from './plus.svg';\n\nconst imagePath = (Icon.Default.prototype as any)._detectIconPath();\nfunction createIcon(colors: Record<string, string>) {\n    let url = defaultIconDataUrl;\n    for (const key of Object.keys(colors)) {\n        url = url.replace(new RegExp(`%24%7b${key}%7d`, 'g'), encodeURIComponent(colors[key]))\n    }\n    return new Icon.Default({ imagePath: new String('') as string, iconUrl: url, iconRetinaUrl: url, shadowUrl: `${imagePath}marker-shadow.png` }) as Icon;\n}\n\nexport const defaultIcon = createIcon({ color1: \"#2e6c97\", color2: \"#3883b7\", color3: \"#126fc6\", color4: \"#4c9cd1\" });\nexport const startIcon = createIcon({ color1: \"#2E9749\", color2: \"#06EA3F\", color3: \"#03D337\", color4: \"#40DD68\" });\nexport const endIcon = createIcon({ color1: \"#972E2E\", color2: \"#B73838\", color3: \"#C61212\", color4: \"#D14C4C\" });\n\nexport const plusIcon = new Icon({\n    iconUrl: plusIconDataUrl,\n    iconSize: [24, 24],\n    iconAnchor: [12, 12]\n});","import { LatLng, LatLngExpression, LeafletEvent, Map, Marker, MarkerOptions, Polyline } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { setPoint } from \"../utils\";\n\nexport default abstract class DraggableLinesMarker extends Marker {\n\n    _draggable: DraggableLinesHandler;\n    _layer: Polyline;\n    _isInsert: boolean;\n\n    _dragIdx?: number | [number, number];\n    _dragFrom?: LatLng;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, isInsert: boolean, options?: MarkerOptions) {\n        super(latlng, options);\n\n        this._draggable = draggable;\n        this._layer = layer;\n        this._isInsert = isInsert;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        this.on(\"dragstart\", this.handleDragStart, this);\n        this.on(\"drag\", this.handleDrag, this);\n        this.on(\"dragend\", this.handleDragEnd, this);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        super.onRemove(map);\n\n        return this;\n    }\n\n    abstract getIdx(): number | [number, number];\n\n    handleDragStart(e: LeafletEvent) {\n        const latlng = this.getLatLng();\n        this._dragFrom = latlng;\n        this._dragIdx = this.getIdx();\n\n        setPoint(this._layer, latlng, this._dragIdx, this._isInsert);\n\n        this._draggable.fire('dragstart', { layer: this._layer, from: latlng, to: latlng, idx: this._dragIdx, isNew: this._isInsert });\n    };\n\n    handleDrag() {\n        const latlng = this.getLatLng();\n\n        setPoint(this._layer, latlng, this._dragIdx!, false);\n\n        this._draggable.fire('drag', { layer: this._layer, from: this._dragFrom!, to: latlng, idx: this._dragIdx!, isNew: this._isInsert });\n    }\n\n    handleDragEnd() {\n        const event = { layer: this._layer, from: this._dragFrom!, to: this.getLatLng(), idx: this._dragIdx!, isNew: this._isInsert };\n\n        Promise.resolve().then(() => {\n            // Set points on the next tick so that Dragging._draggable is unset and DraggableLinesHandler reacts to the route point update\n            // and rerenders the markers.\n            setPoint(event.layer, event.to, event.idx, false);\n            this._draggable.fire('dragend', event);\n        });\n    };\n\n}\n","import { DomUtil, LatLng, LatLngExpression, LeafletMouseEvent, Map, MarkerOptions, Polyline } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport DraggableLinesMarker from \"./marker\";\nimport DraggableLinesTempMarker from \"./tempMarker\";\n\nexport default class DraggableLinesPlusMarker extends DraggableLinesMarker {\n\n    _idx: number | [number, number];\n    _tempMarker?: DraggableLinesPlusTempMarker;\n    _tempMarkerOptions: MarkerOptions;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, idx: number | [number, number], options: MarkerOptions, tempMarkerOptions: MarkerOptions) {\n        super(draggable, layer, latlng, true, {\n            pane: \"overlayPane\",\n            zIndexOffset: -200000,\n            ...options\n        });\n\n        this._idx = idx;\n        this._tempMarkerOptions = tempMarkerOptions;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        this.on('mouseover', this.handleMouseOver, this);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        super.onRemove(map);\n\n        if (this._tempMarker) {\n            this._tempMarker.remove();\n            delete this._tempMarker;\n        }\n        \n        return this;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    handleMouseOver(e: LeafletMouseEvent) {\n        this._draggable.removeTempMarker();\n\n        this._tempMarker = new DraggableLinesPlusTempMarker(this._draggable, this._layer, this, e.latlng, this.getIdx(), this._tempMarkerOptions).addTo(this._map)\n        this._draggable._tempMarker = this._tempMarker;\n    }\n\n}\n\nclass DraggableLinesPlusTempMarker extends DraggableLinesTempMarker {\n    \n    _plusMarker: DraggableLinesPlusMarker;\n    _idx: number | [number, number];\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, plusMarker: DraggableLinesPlusMarker, latlng: LatLngExpression, idx: number | [number, number], options: MarkerOptions) {\n        super(draggable, layer, latlng, options);\n\n        this._plusMarker = plusMarker;\n        this._idx = idx;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    shouldRemove(latlng: LatLng) {\n        const layerPoint = this._map.latLngToLayerPoint(latlng);\n        const position = DomUtil.getPosition(this._plusMarker._icon);\n        return Math.abs(position.y - layerPoint.y) > this._plusMarker._icon.offsetHeight / 2\n            || Math.abs(position.x - layerPoint.x) > this._plusMarker._icon.offsetWidth / 2;\n    }\n\n    getRenderPoint() {\n        return this.getLatLng();\n    }\n\n}","import { DivIcon, DomEvent, Draggable, GeometryUtil, Icon, latLng, LatLng, LatLngExpression, LeafletMouseEvent, Map, MarkerOptions, Polygon, Polyline, Util } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { getInsertPosition, getRouteInsertPosition, setPoint } from \"../utils\";\nimport DraggableLinesMarker from \"./marker\";\n\nfunction createIcon(layer: Polyline, baseIcon: Icon | DivIcon) {\n    const icon = Util.create(baseIcon);\n    const _setIconStyles = icon._setIconStyles;\n    icon._setIconStyles = (img: HTMLImageElement, name: string) => {\n        _setIconStyles.call(icon, img, name);\n\n        // Create a padding around the marker to make sure that we don't accidentally trigger an unwanted mouseout\n        // event while hovering around on the line.\n        const padding = layer.options.weight! * 2;\n        img.style.padding = `${padding}px`;\n        img.style.marginLeft = `${parseInt(img.style.marginLeft) - padding}px`;\n        img.style.marginTop = `${parseInt(img.style.marginTop) - padding}px`;\n    };\n    return icon;\n}\n\nexport default class DraggableLinesTempMarker extends DraggableLinesMarker {\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, options: MarkerOptions) {\n        super(draggable, layer, latlng, true, {\n            draggable: true,\n            zIndexOffset: -100000,\n            ...options,\n            icon: createIcon(layer, options.icon!)\n        });\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        map.on(\"mousemove\", this.handleMapMouseMove, this);\n        DomEvent.on(map.getContainer(), \"mouseover\", this.handleMapMouseOver, this); // Bind manually since map.on(\"mouseover\") does not receive bubbling events\n        this.on('click', this.handleClick, this);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        super.onRemove(map);\n\n        map.off(\"mousemove\", this.handleMapMouseMove, this);\n        DomEvent.off(map.getContainer(), \"mouseover\", this.handleMapMouseOver, this);\n\n        return this;\n    }\n\n    show() {\n        this._icon.style.display = '';\n        if (this._shadow)\n            this._shadow.style.display = '';\n    }\n\n    hide() {\n        this._icon.style.display = 'none';\n        if (this._shadow)\n            this._shadow.style.display = 'none';\n    }\n\n    isHidden() {\n        return this._icon.style.display == 'none';\n    }\n\n    getIdx() {\n        const latlng = this.getLatLng();\n        if (this._layer.hasDraggableLinesRoutePoints())\n            return getRouteInsertPosition(this._map, this._layer.getDraggableLinesRoutePoints()!, this._layer.getLatLngs() as any, latlng);\n        else\n            return getInsertPosition(this._map, this._layer.getLatLngs() as LatLng[] | LatLng[][], latlng, this._layer instanceof Polygon);\n    }\n\n\n    handleClick() {\n        const latlng = this.getLatLng();\n        const idx = this.getIdx();\n\n        setPoint(this._layer, latlng, idx, true);\n\n        this._draggable.fire('insert', { layer: this._layer, latlng, idx });\n    }\n\n\n    shouldRemove(latlng: LatLng) {\n        return !this._layer._containsPoint(this._map.latLngToLayerPoint(latlng));\n    }\n\n\n    getRenderPoint(latlng: LatLng): LatLng | undefined {\n        const closest = GeometryUtil.closest(this._map, this._layer, latlng)!;\n\n        // In case of a polygon, we want to hide the marker while we are hovering the fill, we only want to show\n        // it while we are hovering the outline.\n        if (closest.distance > this._layer.options.weight! / 2 + 1)\n            return undefined;\n        \n        return latLng(closest);\n    }\n\n\n    handleMapMouseMove(e: LeafletMouseEvent) {\n        if (Draggable._dragging)\n            return;\n\n        if (this.shouldRemove(this._map.mouseEventToLatLng(e.originalEvent))) {\n            this.remove();\n            return;\n        }\n\n        const latlng = this.getRenderPoint(this._map.mouseEventToLatLng(e.originalEvent));\n\n        if (latlng)\n            this.setLatLng(latlng);\n\n        const isVisible = !this.isHidden();\n        if (latlng && !isVisible)\n            this.show();\n        else if (!latlng && isVisible)\n            this.hide();\n    };\n\n\n    handleMapMouseOver(e: Event) {\n        if (!Draggable._dragging && e.target !== this.getElement() && e.target !== this._layer.getElement())\n            this.remove();\n    };\n\n}","import L, { LatLng, LineUtil, Map, Polyline } from \"leaflet\";\nimport GeometryUtil from \"leaflet-geometryutil\";\n\nexport type PolylineIndex = number | [number, number];\n\n/**\n * If `points` is the array of coordinates or array of arrays of coordinates that a Polyline/Polygon consists of and `point` is the\n * coordinates where the dragging starts, this method returns the index in the `points` array where the new point should be inserted.\n * The returned value is a number of a tuple of two numbers, depending on whether `points` is an array or an array of arrays.\n *\n * @param map: The instance of `L.Map`.\n * @param points: An array of coordinates or array of arrays of coordinates as returned by `layer.getLatLngs()`.\n * @param point: An instance of `L.LatLng` that represents the point on the line where dragging has started.\n * @param allowExtendingLine: If `true` (default), will return `0` or `points.length` if the dragging has started before the beginning\n * or after the end of the line. If `false`, will always return at least `1` and at most `points.length - 1` to prevent the\n * beginning/end of the line to be modified. Has no effect if `isPolygon` is `true`.\n * @param isPolygon: If `true`, `points` will be considered to be the coordinates of a polygon, if `false` (default), it will be considered\n * the coordinates of a line. The difference between a polygon and a line is that in a polygon, the first point and the last point\n * of the coordinates listed in `points` are connected by an additional segment that can also be dragged.\n */\nexport function getInsertPosition(map: Map, points: LatLng[], point: LatLng, isPolygon?: boolean): number;\nexport function getInsertPosition(map: Map, points: LatLng[][], point: LatLng, isPolygon?: boolean): [number, number];\nexport function getInsertPosition(map: Map, points: LatLng[] | LatLng[][], point: LatLng, isPolygon?: boolean): number | [number, number];\nexport function getInsertPosition(map: Map, points: LatLng[] | LatLng[][], point: LatLng, isPolygon = false): number | [number, number] {\n    if (!LineUtil.isFlat(points)) {\n        // In case of a multi polyline/polygon, we need to figure out first which one of the polylines/polygons the closest point is on.\n        // GeometryUtil.closest() doesn't seem to tell us that, so we need to check the distance to each sub polyline/polygon manually.\n        // Internally, GeometryUtil.closest() seems to do it the same way.\n        let result: { distance: number, i: number } | undefined;\n        for (let i = 0; i < points.length; i++) {\n            const polyline = isPolygon ? L.polygon(points[i]) : L.polyline(points[i]);\n            const distance = GeometryUtil.closest(map, polyline, point)!.distance;\n            if (!result || distance < result.distance) {\n                result = { distance, i };\n            }\n        }\n        return result ? [result.i, getInsertPosition(map, points[result.i], point, isPolygon)] : [0, 0];\n    }\n\n    const polyline = L.polyline(isPolygon ? [...points, points[0]] : points);\n    const pos = GeometryUtil.locateOnLine(map, polyline, point);\n    const before = L.GeometryUtil.extract(map, polyline, 0, pos);\n    \n    let idx = before.length - 1;\n    if (!isPolygon)\n        idx = Math.max(1, Math.min(points.length - 1, idx));\n    return idx;\n}\n\n\n/**\n * Similar to `getInsertPosition`, but for a line where the points returned by `getLatLngs()` (“track points”) are a route that has been\n * calculated to be the best connection between a set of waypoints (“route points”). Dragging starts on a segment between two track\n * points, but should lead an additional point in the set of route points rather than track points, so that the route can be recalculated.\n * This method returns the index where the new route point should be inserted into the array of route points.\n * @param map: The instance of `L.Map`.\n * @param routePoints: An array of coordinates that are the waypoints that are used as the basis for calculating the route.\n * @param trackPoints: An array of coordinates as returned by `layer.getLatLngs()`.\n * @param point: An instance of `L.LatLng` that represents the point on the line where dragging has started.\n */\nexport function getRouteInsertPosition(map: Map, routePoints: LatLng[], trackPoints: LatLng[], point: LatLng): number {\n    const polyline = L.polyline(trackPoints);\n    const pos = GeometryUtil.locateOnLine(map, polyline, point);\n\n    for (let i = 0; i < routePoints.length; i++) {\n        if (GeometryUtil.locateOnLine(map, polyline, routePoints[i]) > pos)\n            return i;\n    }\n    return routePoints.length;\n}\n\nexport function getFromPosition<T, A extends T[] | T[][]>(arr: A, idx: PolylineIndex): T {\n    return Array.isArray(idx) ? (arr as any)[idx[0]][idx[1]] : arr[idx];\n}\n\n/**\n * Returns a copy of the `arr` array with `item` inserted at the index `idx`. `arr` can be an array or an array of arrays (as\n * returned by `getLatLngs()` on a Polyline/Polygon), and `idx` can be a number or a tuple of two numbers as returned by\n * `L.DraggableLines.getInsertPosition()` (and as passed along with the drag events). This method can be used to easily insert\n * a new point at the right position.\n */\nexport function insertAtPosition<T, A extends T[] | T[][]>(arr: A, item: T, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), item, ...arr.slice(idxArr[0])] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = insertAtPosition(result[idxArr[0]] as any, item, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\n/**\n * Like `L.DraggableLines.insertAtPosition`, but overwrites the item at the given index instead of inserting it there.\n * \n * Returns a copy of the `arr` array with the item at index `idx` overwritten with `item`. `arr` can be an array or an array\n * of arrays (as returned by `getLatLngs()` on a Polyline/Polygon), and `idx` can be a number or a tuple of two numbers as\n * returned by `L.DraggableLines.getInsertPosition()` (and as passed along with the drag events). This method can be used\n * to easily update a new point at the right position while the user is dragging:\n */\nexport function updateAtPosition<T, A extends T[] | T[][]>(arr: A, item: T, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), item, ...arr.slice(idxArr[0] + 1)] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = updateAtPosition(result[idxArr[0]] as any, item, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\nexport function removeFromPosition<A extends any[] | any[][]>(arr: A, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), ...arr.slice(idxArr[0] + 1)] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = removeFromPosition(result[idxArr[0]] as any, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\nexport function setPoint(layer: Polyline, point: LatLng, idx: number | [number, number], insert: boolean) {\n    const hasRoutePoints = layer.hasDraggableLinesRoutePoints();\n    \n    let points = hasRoutePoints ? layer.getDraggableLinesRoutePoints()! : layer.getLatLngs() as LatLng[] | LatLng[][];\n    \n    if (insert)\n        points = insertAtPosition(points, point, idx);\n    else\n        points = updateAtPosition(points, point, idx);\n    \n    if (hasRoutePoints)\n        layer.setDraggableLinesRoutePoints(points as any);\n    else\n        layer.setLatLngs(points);\n}\n\nexport function removePoint(layer: Polyline, idx: number | [number, number]) {\n    const hasRoutePoints = layer.hasDraggableLinesRoutePoints();\n    \n    let points = hasRoutePoints ? layer.getDraggableLinesRoutePoints()! : layer.getLatLngs() as LatLng[] | LatLng[][];\n    points = removeFromPosition(points, idx);\n\n    if (hasRoutePoints)\n        layer.setDraggableLinesRoutePoints(points as any);\n    else\n        layer.setLatLngs(points);\n}\n\nexport function getPlusIconPoint(map: Map, trackPoints: LatLng[], distance: number, atStart: boolean) {\n    const tr = atStart ? trackPoints : [...trackPoints].reverse();\n\n    const point0 = map.latLngToContainerPoint(tr[0]);\n    const tr1 = tr.find((p, i) => i > 0 && point0.distanceTo(map.latLngToContainerPoint(p)) > 0);\n\n    let result;\n    if (!tr1) {\n        result = L.point(point0.x + (atStart ? -1 : 1) * distance, point0.y);\n    } else {\n        const point1 = map.latLngToContainerPoint(tr1);\n\n        const fraction = distance / point0.distanceTo(point1);\n\n        console.log(point0, point1, point0.distanceTo(point1));\n\n        result = L.point(point0.x - fraction * (point1.x - point0.x), point0.y - fraction * (point1.y - point0.y));\n    }\n\n    return map.containerPointToLatLng(result);\n}","export default \"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='25.1' height='40.227'%3e %3cdefs%3e %3clinearGradient id='b'%3e %3cstop offset='0' stop-color='%24%7bcolor1%7d' /%3e %3cstop offset='1' stop-color='%24%7bcolor2%7d' /%3e %3c/linearGradient%3e %3clinearGradient id='a'%3e %3cstop offset='0' stop-color='%24%7bcolor3%7d' /%3e %3cstop offset='1' stop-color='%24%7bcolor4%7d' /%3e %3c/linearGradient%3e %3clinearGradient xlink:href='%23a' id='c' gradientUnits='userSpaceOnUse' gradientTransform='translate(-432.796 -503.349)' x1='445.301' y1='541.286' x2='445.301' y2='503.72' /%3e %3clinearGradient xlink:href='%23b' id='d' gradientUnits='userSpaceOnUse' gradientTransform='translate(-341.216 -503.35)' x1='351.748' y1='522.774' x2='351.748' y2='503.721' /%3e %3c/defs%3e %3cpath fill='white' d='M6.329 4.513h12.625v14.5H6.329z' /%3e %3cpath d='M12.594.55C6.021.55.55 6.241.55 12.416c0 2.778 1.564 6.308 2.694 8.746l9.306 17.872 9.262-17.872c1.13-2.438 2.738-5.791 2.738-8.746C24.55 6.241 19.167.55 12.594.55zm0 7.155a4.714 4.714 0 0 1 4.679 4.71c0 2.588-2.095 4.663-4.679 4.679-2.584-.017-4.679-2.09-4.679-4.679a4.714 4.714 0 0 1 4.679-4.71z' fill='url(%23c)' stroke='url(%23d)' stroke-width='1.1' stroke-linecap='round' /%3e %3cpath d='M12.581 1.657c-5.944 0-10.938 5.219-10.938 10.75 0 2.359 1.443 5.832 2.563 8.25l.031.031 8.313 15.969 8.25-15.969.031-.031c1.135-2.448 2.625-5.706 2.625-8.25 0-5.538-4.931-10.75-10.875-10.75zm0 4.969c3.168.021 5.781 2.601 5.781 5.781 0 3.18-2.613 5.761-5.781 5.781-3.168-.02-5.75-2.61-5.75-5.781 0-3.172 2.582-5.761 5.75-5.781z' stroke='white' stroke-width='1.1' stroke-linecap='round' stroke-opacity='.122' fill='none' /%3e %3c/svg%3e\"","export default \"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24'%3e %3cg transform='matrix(.02604 0 0 .02604 1.302 1.302)' fill='none' stroke='black' opacity='0.3'%3e %3ccircle cx='410.9' cy='410.9' r='410.9' color='black' overflow='visible' stroke-width='100' /%3e %3cpath d='M410.9 223.2v375.4M598.6 410.9H223.2' stroke-width='120' stroke-linecap='round' /%3e %3c/g%3e %3c/svg%3e\"","module.exports = __WEBPACK_EXTERNAL_MODULE__453__;","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(607);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}