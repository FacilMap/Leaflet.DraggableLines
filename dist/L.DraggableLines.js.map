{"version":3,"sources":["webpack://L.DraggableLines/webpack/universalModuleDefinition","webpack://L.DraggableLines/./src/handler.ts","webpack://L.DraggableLines/./src/index.ts","webpack://L.DraggableLines/./src/injections.ts","webpack://L.DraggableLines/./src/markers/dragMarker.ts","webpack://L.DraggableLines/./src/markers/icons.ts","webpack://L.DraggableLines/./src/markers/marker.ts","webpack://L.DraggableLines/./src/markers/plusMarker.ts","webpack://L.DraggableLines/./src/markers/tempMarker.ts","webpack://L.DraggableLines/./src/utils.ts","webpack://L.DraggableLines/./src/markers/marker.svg","webpack://L.DraggableLines/./src/markers/plus.svg","webpack://L.DraggableLines/external {\"commonjs\":\"leaflet\",\"commonjs2\":\"leaflet\",\"amd\":\"leaflet\",\"root\":\"L\"}","webpack://L.DraggableLines/external {\"commonjs\":\"leaflet-geometryutil\",\"commonjs2\":\"leaflet-geometryutil\",\"amd\":\"leaflet-geometryutil\",\"root\":[\"L\",\"GeometryUtil\"]}","webpack://L.DraggableLines/webpack/bootstrap","webpack://L.DraggableLines/webpack/startup","webpack://L.DraggableLines/webpack/runtime/define property getters","webpack://L.DraggableLines/webpack/runtime/hasOwnProperty shorthand","webpack://L.DraggableLines/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__453__","__WEBPACK_EXTERNAL_MODULE__7__","map","options","handleLayerAdd","e","layer","Polyline","enableForLayer","handleLayerRemove","disableForLayer","handleLayerMouseOver","Draggable","_dragging","drawTempMarker","target","latlng","handleLayerSetLatLngs","removeTempMarker","_draggableLines","drawDragMarkers","drawPlusMarkers","interactive","startIcon","endIcon","viaIcon","defaultIcon","dragIcon","plusIcon","allowExtendingLine","removeOnClick","addHooks","this","_map","on","eachLayer","removeHooks","removeDragMarkers","latlngs","getDraggableLinesRoutePoints","getLatLngs","routePoints","LineUtil","isFlat","i","length","j","idx","icon","Polygon","marker","addTo","dragMarkers","push","removeFrom","removePlusMarkers","trackPoints","isStart","getPlusIconPoint","weight","plusMarkers","_tempMarker","closest","zoomEndHandler","off","Handler","Object","assign","DraggableLinesHandler","prototype","Evented","DraggableLinesMarker","DraggableLinesDragMarker","DraggableLinesTempMarker","DraggableLinesPlusMarker","DraggableLines","utils","icons","Marker","DragMarker","TempMarker","PlusMarker","hasDraggableLinesRoutePoints","draggableLinesRoutePoints","p","latLng","setDraggableLinesRoutePoints","fire","setLatLngsBkp","setLatLngs","result","apply","args","draggable","_idx","_removeOnClick","onAdd","_layer","points","Array","isArray","handleClick","getIdx","removePoint","_draggable","imagePath","Icon","Default","_detectIconPath","createIcon","colors","url","default","keys","key","replace","RegExp","encodeURIComponent","String","iconUrl","iconRetinaUrl","shadowUrl","color1","color2","color3","color4","iconSize","iconAnchor","isInsert","_isInsert","handleDragStart","handleDrag","handleDragEnd","onRemove","getLatLng","_dragFrom","_dragIdx","setPoint","from","to","isNew","event","Promise","resolve","then","pane","zIndexOffset","_dragIcon","handleMouseOver","remove","DraggableLinesPlusTempMarker","plusMarker","_plusMarker","shouldRemove","layerPoint","latLngToLayerPoint","position","DomUtil","getPosition","_icon","Math","abs","y","offsetHeight","x","offsetWidth","getRenderPoint","baseIcon","Util","create","_setIconStyles","img","name","call","padding","style","marginLeft","parseInt","marginTop","handleMapMouseMove","DomEvent","getContainer","handleMapMouseOver","show","display","_shadow","hide","isHidden","getRouteInsertPosition","getInsertPosition","_containsPoint","GeometryUtil","distance","mouseEventToLatLng","originalEvent","setLatLng","isVisible","getElement","insertAtPosition","arr","item","idxArr","slice","updateAtPosition","removeFromPosition","point","isPolygon","polygon","polyline","pos","locateOnLine","extract","max","min","insert","hasRoutePoints","atStart","tr","reverse","point0","latLngToContainerPoint","point1","fraction","distanceTo","containerPointToLatLng","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","o","defineProperty","enumerable","get","obj","prop","hasOwnProperty","r","Symbol","toStringTag","value"],"mappings":"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","file":"L.DraggableLines.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"leaflet\"), require(\"leaflet-geometryutil\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"leaflet\", \"leaflet-geometryutil\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"L.DraggableLines\"] = factory(require(\"leaflet\"), require(\"leaflet-geometryutil\"));\n\telse\n\t\troot[\"L.DraggableLines\"] = factory(root[\"L\"], root[\"L\"][\"GeometryUtil\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__453__, __WEBPACK_EXTERNAL_MODULE__7__) {\nreturn ","import L, { Draggable, Evented, Handler, Icon, LatLng, Layer, LeafletEvent, LeafletMouseEvent, LineUtil, Map, Marker, Polygon, Polyline } from 'leaflet';\nimport GeometryUtil from 'leaflet-geometryutil';\nimport { defaultIcon, endIcon, plusIcon, startIcon } from './markers/icons';\nimport DraggableLinesDragMarker from './markers/dragMarker';\nimport DraggableLinesPlusMarker from './markers/plusMarker';\nimport DraggableLinesTempMarker from './markers/tempMarker';\nimport { getPlusIconPoint } from './utils';\n\nexport interface DraggableLinesHandlerOptions {\n    enableForLayer?: (layer: Polyline) => boolean;\n    viaIcon?: Icon;\n    startIcon?: Icon;\n    endIcon?: Icon;\n    dragIcon?: Icon;\n    plusIcon?: Icon;\n    allowExtendingLine?: boolean;\n    removeOnClick?: boolean;\n}\n\nexport default class DraggableLinesHandler extends Handler {\n\n    options: DraggableLinesHandlerOptions;\n    \n    _tempMarker?: DraggableLinesTempMarker;\n\n    constructor(map: Map, options?: DraggableLinesHandlerOptions) {\n        super(map);\n\n        this.options = {\n            enableForLayer: (layer) => layer.options.interactive!,\n            startIcon,\n            endIcon,\n            viaIcon: defaultIcon,\n            dragIcon: defaultIcon,\n            plusIcon,\n            allowExtendingLine: true,\n            removeOnClick: true,\n            ...options\n        };\n    }\n\n    addHooks() {\n        this._map.on(\"layeradd\", this.handleLayerAdd);\n        this._map.on(\"layerremove\", this.handleLayerRemove);\n\n        this._map.eachLayer((layer) => { this.handleLayerAdd({ layer }); });\n    }\n\n    removeHooks() {\n        this._map.on(\"layeradd\", this.handleLayerAdd);\n        this._map.on(\"layerremove\", this.handleLayerRemove);\n\n        this._map.eachLayer((layer) => { this.handleLayerRemove({ layer }); });\n    }\n\n    handleLayerAdd = (e: { layer: Layer }) => {\n        if (e.layer instanceof Polyline && this.options.enableForLayer!(e.layer))\n            this.enableForLayer(e.layer as Polyline);\n    };\n\n    handleLayerRemove = (e: { layer: Layer }) => {\n        if (e.layer instanceof Polyline)\n            this.disableForLayer(e.layer as Polyline);\n    };\n\n    handleLayerMouseOver = (e: LeafletMouseEvent) => {\n        if (Draggable._dragging)\n            return;\n\n        this.drawTempMarker(e.target as Polyline, e.latlng);\n    };\n\n    handleLayerSetLatLngs = (e: LeafletEvent) => {\n        const layer = e.target as Polyline;\n        if (!Draggable._dragging) {\n            this.removeTempMarker();\n\n            if (layer._draggableLines) {\n                this.drawDragMarkers(layer);\n                this.drawPlusMarkers(layer);\n            }\n        }\n    };\n\n    drawDragMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n\n        this.removeDragMarkers(layer);\n        \n        const latlngs = layer.getDraggableLinesRoutePoints() || (layer.getLatLngs() as LatLng[] | LatLng[][]);\n        const routePoints = LineUtil.isFlat(latlngs) ? [latlngs] : latlngs;\n        const isFlat = LineUtil.isFlat(latlngs);\n        for (let i = 0; i < routePoints.length; i++) {\n            for (let j = 0; j < routePoints[i].length; j++) {\n                const idx = isFlat ? j : [i, j] as [number, number];\n\n                let removeOnClick = this.options.removeOnClick!;\n                let icon = this.options.viaIcon!;\n                if (!(layer instanceof Polygon)) {\n                    icon = j == 0 ? this.options.startIcon! : j == routePoints[i].length - 1 ? this.options.endIcon! : icon;\n\n                    //if (j == 0 || j == routePoints[i].length - 1)\n                    //    removeOnClick = removeOnClick && this.options.allowExtendingLine!;\n                }\n\n                const marker = new DraggableLinesDragMarker(this, layer, routePoints[i][j], idx, icon, removeOnClick).addTo(this._map);\n                layer._draggableLines.dragMarkers.push(marker);\n            }\n        }\n    }\n\n    removeDragMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n        \n        for (const marker of layer._draggableLines.dragMarkers) {\n            marker.removeFrom(this._map);\n        }\n        layer._draggableLines.dragMarkers = [];\n    }\n\n    drawPlusMarkers(layer: Polyline) {\n        if (layer instanceof Polygon || !layer._draggableLines || !this.options.allowExtendingLine)\n            return;\n\n        this.removePlusMarkers(layer);\n\n        const latlngs = layer.getLatLngs() as LatLng[] | LatLng[][];\n        const trackPoints = LineUtil.isFlat(latlngs) ? [latlngs] : latlngs;\n        const routePoints = layer.getDraggableLinesRoutePoints();\n        \n        for (let i = 0; i < trackPoints.length; i++) {\n            if (trackPoints[i].length < 2)\n                continue;\n\n            for (const isStart of [true, false]) {\n                let idx: number | [number, number];\n                if (routePoints)\n                    idx = isStart ? 0 : routePoints.length;\n                else if (LineUtil.isFlat(latlngs))\n                    idx = isStart ? 0 : trackPoints[i].length;\n                else\n                    idx = isStart ? [i, 0] : [i, trackPoints[i].length];\n                \n                const marker = new DraggableLinesPlusMarker(this, layer, getPlusIconPoint(this._map, trackPoints[i], 24 + layer.options.weight! / 2, isStart), idx).addTo(this._map);\n                layer._draggableLines.plusMarkers.push(marker);\n            }\n        }\n    }\n\n    removePlusMarkers(layer: Polyline) {\n        if (!layer._draggableLines)\n            return;\n        \n        for (const marker of layer._draggableLines.plusMarkers) {\n            marker.removeFrom(this._map);\n        }\n        layer._draggableLines.plusMarkers = [];\n    }\n\n    drawTempMarker(layer: Polyline, latlng: LatLng) {\n        this.removeTempMarker();\n\n        this._tempMarker = new DraggableLinesTempMarker(this, layer, GeometryUtil.closest(this._map, layer, latlng)!).addTo(this._map);\n    }\n\n    removeTempMarker() {\n        if (this._tempMarker) {\n            this._tempMarker.removeFrom(this._map);\n            delete this._tempMarker;\n        }\n    }\n\n    enableForLayer(layer: Polyline) {\n        if (layer._draggableLines)\n            return;\n\n        layer._draggableLines = {\n            dragMarkers: [],\n            plusMarkers: [],\n            zoomEndHandler: () => {\n                this.drawPlusMarkers(layer);\n            }\n        };\n        layer.on(\"mouseover\", this.handleLayerMouseOver);\n        layer.on(\"draggableLines-setLatLngs\", this.handleLayerSetLatLngs);\n        layer.on(\"draggableLines-setRoutePoints\", this.handleLayerSetLatLngs);\n        this._map.on(\"zoomend\", layer._draggableLines.zoomEndHandler);\n        this.drawDragMarkers(layer);\n        this.drawPlusMarkers(layer);\n    }\n\n    disableForLayer(layer: Polyline) {\n        layer.off(\"mouseover\", this.handleLayerMouseOver);\n        layer.off(\"draggableLines-setLatLngs\", this.handleLayerSetLatLngs);\n        layer.off(\"draggableLines-setRoutePoints\", this.handleLayerSetLatLngs);\n        if (layer._draggableLines)\n            this._map.off(\"zoomend\", layer._draggableLines.zoomEndHandler);\n        this.removeDragMarkers(layer);\n        this.removePlusMarkers(layer);\n        delete layer._draggableLines;\n    }\n\n}\n\nexport default interface DraggableLinesHandler extends Evented {}\nObject.assign(DraggableLinesHandler.prototype, Evented.prototype);\n","import L from 'leaflet';\nimport DraggableLinesHandler from './handler';\nimport './injections';\nimport * as utils from './utils';\nimport * as icons from './markers/icons';\nimport DraggableLinesMarker from './markers/marker';\nimport DraggableLinesDragMarker from './markers/dragMarker';\nimport DraggableLinesTempMarker from './markers/tempMarker';\nimport DraggableLinesPlusMarker from './markers/plusMarker';\n\nexport * from './utils';\nexport * from './markers/icons';\nexport { DraggableLinesMarker, DraggableLinesDragMarker, DraggableLinesTempMarker, DraggableLinesPlusMarker };\n\ntype DraggableLinesType = typeof DraggableLinesHandler;\n\ndeclare module \"leaflet\" {\n    let DraggableLines: DraggableLinesType\n        & typeof utils\n        & {\n            icons: typeof icons;\n            Marker: typeof DraggableLinesMarker;\n            DragMarker: typeof DraggableLinesDragMarker;\n            TempMarker: typeof DraggableLinesTempMarker;\n            PlusMarker: typeof DraggableLinesPlusMarker;\n        };\n}\n\nL.DraggableLines = Object.assign(DraggableLinesHandler, {\n    ...utils,\n    icons,\n    Marker: DraggableLinesMarker,\n    DragMarker: DraggableLinesDragMarker,\n    TempMarker: DraggableLinesTempMarker,\n    PlusMarker: DraggableLinesPlusMarker\n});\n\nexport default DraggableLinesHandler;","import { latLng, LatLngExpression, Marker, Polyline } from \"leaflet\";\n\nPolyline.prototype.hasDraggableLinesRoutePoints = function() {\n    return this.options.draggableLinesRoutePoints != null;\n};\n\nPolyline.prototype.getDraggableLinesRoutePoints = function() {\n    return this.options.draggableLinesRoutePoints?.map((p) => latLng(p));\n};\n\nPolyline.prototype.setDraggableLinesRoutePoints = function(routePoints: LatLngExpression[] | undefined) {\n    this.options.draggableLinesRoutePoints = routePoints;\n    this.fire('draggableLines-setRoutePoints');\n};\n\nconst setLatLngsBkp = Polyline.prototype.setLatLngs;\nPolyline.prototype.setLatLngs = function(...args: any) {\n    const result = setLatLngsBkp.apply(this, args);\n    this.fire('draggableLines-setLatLngs');\n    return result;\n};\n\ninterface PolylineInfo {\n    dragMarkers: Marker[];\n    plusMarkers: Marker[];\n    zoomEndHandler: () => void;\n}\n\ndeclare module \"leaflet\" {\n    interface Polyline {\n        hasDraggableLinesRoutePoints: () => boolean;\n        getDraggableLinesRoutePoints: () => LatLng[] | undefined;\n        setDraggableLinesRoutePoints: (routePoints: LatLngExpression[] | undefined) => void;\n    }\n\n    interface PolylineOptions {\n        draggableLinesRoutePoints?: LatLngExpression[];\n    }\n\n    interface Polyline {\n        _draggableLines?: PolylineInfo;\n    }\n}","import { Icon, LatLng, LatLngExpression, Map, Polygon, Polyline } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { removePoint } from \"../utils\";\nimport DraggableLinesMarker from \"./marker\";\n\nexport default class DraggableLinesDragMarker extends DraggableLinesMarker {\n\n    _idx: number | [number, number];\n    _removeOnClick: boolean;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, idx: number | [number, number], icon: Icon, removeOnClick: boolean) {\n        super(draggable, layer, latlng, false, {\n            icon,\n            draggable: true\n        });\n\n        this._idx = idx;\n        this._removeOnClick = removeOnClick;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        const latlngs = this._layer.getDraggableLinesRoutePoints() || (this._layer.getLatLngs() as LatLng[] | LatLng[][]);\n        const points = Array.isArray(this._idx) ? (latlngs as LatLng[][])[this._idx[0]] : (latlngs as LatLng[]);\n\n        if (this._removeOnClick && points.length > (this._layer instanceof Polygon ? 3 : 2)) {\n            this.on('click', this.handleClick);\n        }\n\n        return this;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    handleClick() {\n        const idx = this.getIdx();\n\n        removePoint(this._layer, idx);\n        // Markers are redrawn automatically because we update the line points\n\n        this._draggable.fire('remove', { layer: this._layer, idx });\n    }\n\n}\n","import { Icon } from 'leaflet';\nimport defaultIconDataUrl from './marker.svg';\nimport plusIconDataUrl from './plus.svg';\n\nconst imagePath = (Icon.Default.prototype as any)._detectIconPath();\nfunction createIcon(colors: Record<string, string>) {\n    let url = defaultIconDataUrl;\n    for (const key of Object.keys(colors)) {\n        url = url.replace(new RegExp(`%24%7b${key}%7d`, 'g'), encodeURIComponent(colors[key]))\n    }\n    return new Icon.Default({ imagePath: new String('') as string, iconUrl: url, iconRetinaUrl: url, shadowUrl: `${imagePath}marker-shadow.png` }) as Icon;\n}\n\nexport const defaultIcon = createIcon({ color1: \"#2e6c97\", color2: \"#3883b7\", color3: \"#126fc6\", color4: \"#4c9cd1\" });\nexport const startIcon = createIcon({ color1: \"#2E9749\", color2: \"#06EA3F\", color3: \"#03D337\", color4: \"#40DD68\" });\nexport const endIcon = createIcon({ color1: \"#972E2E\", color2: \"#B73838\", color3: \"#C61212\", color4: \"#D14C4C\" });\n\nexport const plusIcon = new Icon({\n    iconUrl: plusIconDataUrl,\n    iconSize: [24, 24],\n    iconAnchor: [12, 12]\n});","import { LatLng, LatLngExpression, LeafletEvent, Map, Marker, MarkerOptions, Polyline } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { setPoint } from \"../utils\";\n\nexport default abstract class DraggableLinesMarker extends Marker {\n\n    _draggable: DraggableLinesHandler;\n    _layer: Polyline;\n    _isInsert: boolean;\n\n    _dragIdx?: number | [number, number];\n    _dragFrom?: LatLng;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, isInsert: boolean, options?: MarkerOptions) {\n        super(latlng, options);\n\n        this._draggable = draggable;\n        this._layer = layer;\n        this._isInsert = isInsert;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        this.on(\"dragstart\", this.handleDragStart, this);\n        this.on(\"drag\", this.handleDrag, this);\n        this.on(\"dragend\", this.handleDragEnd, this);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        super.onRemove(map);\n\n        return this;\n    }\n\n    abstract getIdx(): number | [number, number];\n\n    handleDragStart(e: LeafletEvent) {\n        const latlng = this.getLatLng();\n        this._dragFrom = latlng;\n        this._dragIdx = this.getIdx();\n\n        setPoint(this._layer, latlng, this._dragIdx, this._isInsert);\n\n        this._draggable.fire('dragstart', { layer: this._layer, from: latlng, to: latlng, idx: this._dragIdx, isNew: this._isInsert });\n    };\n\n    handleDrag() {\n        const latlng = this.getLatLng();\n\n        setPoint(this._layer, latlng, this._dragIdx!, false);\n\n        this._draggable.fire('drag', { layer: this._layer, from: this._dragFrom!, to: latlng, idx: this._dragIdx!, isNew: this._isInsert });\n    }\n\n    handleDragEnd() {\n        const event = { layer: this._layer, from: this._dragFrom!, to: this.getLatLng(), idx: this._dragIdx!, isNew: this._isInsert };\n\n        Promise.resolve().then(() => {\n            // Set points on the next tick so that Dragging._draggable is unset and DraggableLinesHandler reacts to the route point update\n            // and rerenders the markers.\n            setPoint(event.layer, event.to, event.idx, false);\n            this._draggable.fire('dragend', event);\n        });\n    };\n\n}\n","import { DomUtil, Icon, LatLng, LatLngExpression, LeafletMouseEvent, Map, Point, Polyline } from \"leaflet\";\nimport DraggableLinesHandler, { DraggableLinesHandlerOptions } from \"../handler\";\nimport { setPoint } from \"../utils\";\nimport DraggableLinesMarker from \"./marker\";\nimport DraggableLinesTempMarker from \"./tempMarker\";\n\nfunction isStart(idx: number | [number, number]): boolean {\n    return (Array.isArray(idx) ? idx[1] : idx) == 0;\n}\n\nexport default class DraggableLinesPlusMarker extends DraggableLinesMarker {\n\n    _idx: number | [number, number];\n    _dragIcon: Icon;\n    _tempMarker?: DraggableLinesPlusTempMarker;\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, idx: number | [number, number]) {\n        super(draggable, layer, latlng, true, {\n            icon: draggable.options.plusIcon,\n            pane: \"overlayPane\",\n            zIndexOffset: -200000\n        });\n\n        this._idx = idx;\n        this._dragIcon = isStart(idx) ? draggable.options.startIcon! : draggable.options.endIcon!;\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        this.on('mouseover', this.handleMouseOver, this);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        super.onRemove(map);\n\n        if (this._tempMarker) {\n            this._tempMarker.remove();\n            delete this._tempMarker;\n        }\n        \n        return this;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    handleMouseOver(e: LeafletMouseEvent) {\n        this._draggable.removeTempMarker();\n\n        this._tempMarker = new DraggableLinesPlusTempMarker(this._draggable, this._layer, this, e.latlng, this.getIdx(), this._dragIcon).addTo(this._map)\n        this._draggable._tempMarker = this._tempMarker;\n    }\n\n}\n\nclass DraggableLinesPlusTempMarker extends DraggableLinesTempMarker {\n    \n    _plusMarker: DraggableLinesPlusMarker;\n    _idx: number | [number, number];\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, plusMarker: DraggableLinesPlusMarker, latlng: LatLngExpression, idx: number | [number, number], icon: Icon) {\n        super(draggable, layer, latlng, icon);\n\n        this._plusMarker = plusMarker;\n        this._idx = idx;\n    }\n\n    getIdx() {\n        return this._idx;\n    }\n\n    shouldRemove(latlng: LatLng) {\n        const layerPoint = this._map.latLngToLayerPoint(latlng);\n        const position = DomUtil.getPosition(this._plusMarker._icon);\n        return Math.abs(position.y - layerPoint.y) > this._plusMarker._icon.offsetHeight / 2\n            || Math.abs(position.x - layerPoint.x) > this._plusMarker._icon.offsetWidth / 2;\n    }\n\n    getRenderPoint() {\n        return this.getLatLng();\n    }\n\n}","import { DomEvent, Draggable, GeometryUtil, Icon, latLng, LatLng, LatLngExpression, LeafletMouseEvent, Map, Polygon, Polyline, Util } from \"leaflet\";\nimport DraggableLinesHandler from \"../handler\";\nimport { getInsertPosition, getRouteInsertPosition, setPoint } from \"../utils\";\nimport DraggableLinesMarker from \"./marker\";\n\nfunction createIcon(layer: Polyline, baseIcon: Icon) {\n    const icon = Util.create(baseIcon);\n    const _setIconStyles = icon._setIconStyles;\n    icon._setIconStyles = (img: HTMLImageElement, name: string) => {\n        _setIconStyles.call(icon, img, name);\n\n        // Create a padding around the marker to make sure that we don't accidentally trigger an unwanted mouseout\n        // event while hovering around on the line.\n        const padding = layer.options.weight! * 2;\n        img.style.padding = `${padding}px`;\n        img.style.marginLeft = `${parseInt(img.style.marginLeft) - padding}px`;\n        img.style.marginTop = `${parseInt(img.style.marginTop) - padding}px`;\n    };\n    return icon;\n}\n\nexport default class DraggableLinesTempMarker extends DraggableLinesMarker {\n\n    constructor(draggable: DraggableLinesHandler, layer: Polyline, latlng: LatLngExpression, icon?: Icon) {\n        super(draggable, layer, latlng, true, {\n            icon: createIcon(layer, icon ?? draggable.options.dragIcon!),\n            draggable: true,\n            zIndexOffset: -100000\n        });\n    }\n\n    onAdd(map: Map) {\n        super.onAdd(map);\n\n        map.on(\"mousemove\", this.handleMapMouseMove, this);\n        DomEvent.on(map.getContainer(), \"mouseover\", this.handleMapMouseOver, this); // Bind manually since map.on(\"mouseover\") does not receive bubbling events\n        this.on('click', this.handleClick, this);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        super.onRemove(map);\n\n        map.off(\"mousemove\", this.handleMapMouseMove, this);\n        DomEvent.off(map.getContainer(), \"mouseover\", this.handleMapMouseOver, this);\n\n        return this;\n    }\n\n    show() {\n        this._icon.style.display = '';\n        if (this._shadow)\n            this._shadow.style.display = '';\n    }\n\n    hide() {\n        this._icon.style.display = 'none';\n        if (this._shadow)\n            this._shadow.style.display = 'none';\n    }\n\n    isHidden() {\n        return this._icon.style.display == 'none';\n    }\n\n    getIdx() {\n        const latlng = this.getLatLng();\n        if (this._layer.hasDraggableLinesRoutePoints())\n            return getRouteInsertPosition(this._map, this._layer.getDraggableLinesRoutePoints()!, this._layer.getLatLngs() as any, latlng);\n        else\n            return getInsertPosition(this._map, this._layer.getLatLngs() as LatLng[] | LatLng[][], latlng, this._layer instanceof Polygon);\n    }\n\n\n    handleClick() {\n        const latlng = this.getLatLng();\n        const idx = this.getIdx();\n\n        setPoint(this._layer, latlng, idx, true);\n\n        this._draggable.fire('insert', { layer: this._layer, latlng, idx });\n    }\n\n\n    shouldRemove(latlng: LatLng) {\n        return !this._layer._containsPoint(this._map.latLngToLayerPoint(latlng));\n    }\n\n\n    getRenderPoint(latlng: LatLng): LatLng | undefined {\n        const closest = GeometryUtil.closest(this._map, this._layer, latlng)!;\n\n        // In case of a polygon, we want to hide the marker while we are hovering the fill, we only want to show\n        // it while we are hovering the outline.\n        if (closest.distance > this._layer.options.weight! / 2 + 1)\n            return undefined;\n        \n        return latLng(closest);\n    }\n\n\n    handleMapMouseMove(e: LeafletMouseEvent) {\n        if (Draggable._dragging)\n            return;\n\n        if (this.shouldRemove(this._map.mouseEventToLatLng(e.originalEvent))) {\n            this.remove();\n            return;\n        }\n\n        const latlng = this.getRenderPoint(this._map.mouseEventToLatLng(e.originalEvent));\n\n        if (latlng)\n            this.setLatLng(latlng);\n\n        const isVisible = !this.isHidden();\n        if (latlng && !isVisible)\n            this.show();\n        else if (!latlng && isVisible)\n            this.hide();\n    };\n\n\n    handleMapMouseOver(e: Event) {\n        if (e.target !== this.getElement() && e.target !== this._layer.getElement())\n            this.remove();\n    };\n\n}","import L, { LatLng, LineUtil, Map, Polyline } from \"leaflet\";\nimport GeometryUtil from \"leaflet-geometryutil\";\n\nexport type PolylineIndex = number | [number, number];\n\n/**\n * If `points` is the array of coordinates or array of arrays of coordinates that a Polyline/Polygon consists of and `point` is the\n * coordinates where the dragging starts, this method returns the index in the `points` array where the new point should be inserted.\n * The returned value is a number of a tuple of two numbers, depending on whether `points` is an array or an array of arrays.\n *\n * @param map: The instance of `L.Map`.\n * @param points: An array of coordinates or array of arrays of coordinates as returned by `layer.getLatLngs()`.\n * @param point: An instance of `L.LatLng` that represents the point on the line where dragging has started.\n * @param allowExtendingLine: If `true` (default), will return `0` or `points.length` if the dragging has started before the beginning\n * or after the end of the line. If `false`, will always return at least `1` and at most `points.length - 1` to prevent the\n * beginning/end of the line to be modified. Has no effect if `isPolygon` is `true`.\n * @param isPolygon: If `true`, `points` will be considered to be the coordinates of a polygon, if `false` (default), it will be considered\n * the coordinates of a line. The difference between a polygon and a line is that in a polygon, the first point and the last point\n * of the coordinates listed in `points` are connected by an additional segment that can also be dragged.\n */\nexport function getInsertPosition(map: Map, points: LatLng[], point: LatLng, isPolygon?: boolean): number;\nexport function getInsertPosition(map: Map, points: LatLng[][], point: LatLng, isPolygon?: boolean): [number, number];\nexport function getInsertPosition(map: Map, points: LatLng[] | LatLng[][], point: LatLng, isPolygon?: boolean): number | [number, number];\nexport function getInsertPosition(map: Map, points: LatLng[] | LatLng[][], point: LatLng, isPolygon = false): number | [number, number] {\n    if (!LineUtil.isFlat(points)) {\n        // In case of a multi polyline/polygon, we need to figure out first which one of the polylines/polygons the closest point is on.\n        // GeometryUtil.closest() doesn't seem to tell us that, so we need to check the distance to each sub polyline/polygon manually.\n        // Internally, GeometryUtil.closest() seems to do it the same way.\n        let result: { distance: number, i: number } | undefined;\n        for (let i = 0; i < points.length; i++) {\n            const polyline = isPolygon ? L.polygon(points[i]) : L.polyline(points[i]);\n            const distance = GeometryUtil.closest(map, polyline, point)!.distance;\n            if (!result || distance < result.distance) {\n                result = { distance, i };\n            }\n        }\n        return result ? [result.i, getInsertPosition(map, points[result.i], point, isPolygon)] : [0, 0];\n    }\n\n    const polyline = L.polyline(isPolygon ? [...points, points[0]] : points);\n    const pos = GeometryUtil.locateOnLine(map, polyline, point);\n    const before = L.GeometryUtil.extract(map, polyline, 0, pos);\n    \n    let idx = before.length - 1;\n    if (!isPolygon)\n        idx = Math.max(1, Math.min(points.length - 1, idx));\n    return idx;\n}\n\n\n/**\n * Similar to `getInsertPosition`, but for a line where the points returned by `getLatLngs()` (“track points”) are a route that has been\n * calculated to be the best connection between a set of waypoints (“route points”). Dragging starts on a segment between two track\n * points, but should lead an additional point in the set of route points rather than track points, so that the route can be recalculated.\n * This method returns the index where the new route point should be inserted into the array of route points.\n * @param map: The instance of `L.Map`.\n * @param routePoints: An array of coordinates that are the waypoints that are used as the basis for calculating the route.\n * @param trackPoints: An array of coordinates as returned by `layer.getLatLngs()`.\n * @param point: An instance of `L.LatLng` that represents the point on the line where dragging has started.\n */\nexport function getRouteInsertPosition(map: Map, routePoints: LatLng[], trackPoints: LatLng[], point: LatLng): number {\n    const polyline = L.polyline(trackPoints);\n    const pos = GeometryUtil.locateOnLine(map, polyline, point);\n\n    for (let i = 0; i < routePoints.length; i++) {\n        if (GeometryUtil.locateOnLine(map, polyline, routePoints[i]) > pos)\n            return i;\n    }\n    return routePoints.length;\n}\n\nexport function getFromPosition<T, A extends T[] | T[][]>(arr: A, idx: PolylineIndex): T {\n    return Array.isArray(idx) ? (arr as any)[idx[0]][idx[1]] : arr[idx];\n}\n\n/**\n * Returns a copy of the `arr` array with `item` inserted at the index `idx`. `arr` can be an array or an array of arrays (as\n * returned by `getLatLngs()` on a Polyline/Polygon), and `idx` can be a number or a tuple of two numbers as returned by\n * `L.DraggableLines.getInsertPosition()` (and as passed along with the drag events). This method can be used to easily insert\n * a new point at the right position.\n */\nexport function insertAtPosition<T, A extends T[] | T[][]>(arr: A, item: T, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), item, ...arr.slice(idxArr[0])] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = insertAtPosition(result[idxArr[0]] as any, item, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\n/**\n * Like `L.DraggableLines.insertAtPosition`, but overwrites the item at the given index instead of inserting it there.\n * \n * Returns a copy of the `arr` array with the item at index `idx` overwritten with `item`. `arr` can be an array or an array\n * of arrays (as returned by `getLatLngs()` on a Polyline/Polygon), and `idx` can be a number or a tuple of two numbers as\n * returned by `L.DraggableLines.getInsertPosition()` (and as passed along with the drag events). This method can be used\n * to easily update a new point at the right position while the user is dragging:\n */\nexport function updateAtPosition<T, A extends T[] | T[][]>(arr: A, item: T, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), item, ...arr.slice(idxArr[0] + 1)] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = updateAtPosition(result[idxArr[0]] as any, item, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\nexport function removeFromPosition<A extends any[] | any[][]>(arr: A, idx: number | [number, number]): A {\n    const idxArr = Array.isArray(idx) ? idx : [idx];\n\n    if (idxArr.length === 0) {\n        return arr;\n    } else if (idxArr.length === 1) {\n        return [...arr.slice(0, idxArr[0]), ...arr.slice(idxArr[0] + 1)] as any;\n    } else {\n        const result = [...arr];\n        result[idxArr[0]] = removeFromPosition(result[idxArr[0]] as any, idxArr.slice(1) as any);\n        return result as any;\n    }\n}\n\nexport function setPoint(layer: Polyline, point: LatLng, idx: number | [number, number], insert: boolean) {\n    const hasRoutePoints = layer.hasDraggableLinesRoutePoints();\n    \n    let points = hasRoutePoints ? layer.getDraggableLinesRoutePoints()! : layer.getLatLngs() as LatLng[] | LatLng[][];\n    \n    if (insert)\n        points = insertAtPosition(points, point, idx);\n    else\n        points = updateAtPosition(points, point, idx);\n    \n    if (hasRoutePoints)\n        layer.setDraggableLinesRoutePoints(points as any);\n    else\n        layer.setLatLngs(points);\n}\n\nexport function removePoint(layer: Polyline, idx: number | [number, number]) {\n    const hasRoutePoints = layer.hasDraggableLinesRoutePoints();\n    \n    let points = hasRoutePoints ? layer.getDraggableLinesRoutePoints()! : layer.getLatLngs() as LatLng[] | LatLng[][];\n    points = removeFromPosition(points, idx);\n\n    if (hasRoutePoints)\n        layer.setDraggableLinesRoutePoints(points as any);\n    else\n        layer.setLatLngs(points);\n}\n\nexport function getPlusIconPoint(map: Map, trackPoints: LatLng[], distance: number, atStart: boolean) {\n    const tr = atStart ? trackPoints : [...trackPoints].reverse();\n\n    const point0 = map.latLngToContainerPoint(tr[0]);\n    const point1 = map.latLngToContainerPoint(tr[1]);\n\n    const fraction = distance / point0.distanceTo(point1);\n    const result = L.point(point0.x - fraction * (point1.x - point0.x), point0.y - fraction * (point1.y - point0.y));\n    return map.containerPointToLatLng(result);\n}","export default \"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='25.1' height='40.227'%3e %3cdefs%3e %3clinearGradient id='b'%3e %3cstop offset='0' stop-color='%24%7bcolor1%7d' /%3e %3cstop offset='1' stop-color='%24%7bcolor2%7d' /%3e %3c/linearGradient%3e %3clinearGradient id='a'%3e %3cstop offset='0' stop-color='%24%7bcolor3%7d' /%3e %3cstop offset='1' stop-color='%24%7bcolor4%7d' /%3e %3c/linearGradient%3e %3clinearGradient xlink:href='%23a' id='c' gradientUnits='userSpaceOnUse' gradientTransform='translate(-432.796 -503.349)' x1='445.301' y1='541.286' x2='445.301' y2='503.72' /%3e %3clinearGradient xlink:href='%23b' id='d' gradientUnits='userSpaceOnUse' gradientTransform='translate(-341.216 -503.35)' x1='351.748' y1='522.774' x2='351.748' y2='503.721' /%3e %3c/defs%3e %3cpath fill='white' d='M6.329 4.513h12.625v14.5H6.329z' /%3e %3cpath d='M12.594.55C6.021.55.55 6.241.55 12.416c0 2.778 1.564 6.308 2.694 8.746l9.306 17.872 9.262-17.872c1.13-2.438 2.738-5.791 2.738-8.746C24.55 6.241 19.167.55 12.594.55zm0 7.155a4.714 4.714 0 0 1 4.679 4.71c0 2.588-2.095 4.663-4.679 4.679-2.584-.017-4.679-2.09-4.679-4.679a4.714 4.714 0 0 1 4.679-4.71z' fill='url(%23c)' stroke='url(%23d)' stroke-width='1.1' stroke-linecap='round' /%3e %3cpath d='M12.581 1.657c-5.944 0-10.938 5.219-10.938 10.75 0 2.359 1.443 5.832 2.563 8.25l.031.031 8.313 15.969 8.25-15.969.031-.031c1.135-2.448 2.625-5.706 2.625-8.25 0-5.538-4.931-10.75-10.875-10.75zm0 4.969c3.168.021 5.781 2.601 5.781 5.781 0 3.18-2.613 5.761-5.781 5.781-3.168-.02-5.75-2.61-5.75-5.781 0-3.172 2.582-5.761 5.75-5.781z' stroke='white' stroke-width='1.1' stroke-linecap='round' stroke-opacity='.122' fill='none' /%3e %3c/svg%3e\"","export default \"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24'%3e %3cg transform='matrix(.02604 0 0 .02604 1.302 1.302)' fill='none' stroke='black' opacity='0.3'%3e %3ccircle cx='410.9' cy='410.9' r='410.9' color='black' overflow='visible' stroke-width='100' /%3e %3cpath d='M410.9 223.2v375.4M598.6 410.9H223.2' stroke-width='120' stroke-linecap='round' /%3e %3c/g%3e %3c/svg%3e\"","module.exports = __WEBPACK_EXTERNAL_MODULE__453__;","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(607);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}